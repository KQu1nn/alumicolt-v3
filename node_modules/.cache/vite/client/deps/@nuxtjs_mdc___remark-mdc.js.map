{
  "version": 3,
  "sources": ["../../../../remark-mdc/dist/index.mjs", "../../../../flat/index.js", "../../../../stringify-entities/lib/core.js", "../../../../character-entities-legacy/index.js", "../../../../character-entities-html4/index.js", "../../../../stringify-entities/lib/util/to-named.js", "../../../../stringify-entities/lib/util/format-basic.js", "../../../../stringify-entities/lib/index.js", "../../../../character-reference-invalid/index.js", "../../../../is-decimal/index.js", "../../../../is-hexadecimal/index.js", "../../../../is-alphabetical/index.js", "../../../../is-alphanumerical/index.js", "../../../../parse-entities/lib/index.js"],
  "sourcesContent": ["import { kebabCase } from 'scule';\nimport { visit } from 'unist-util-visit';\nimport { parseDocument, isMap, isSeq, isScalar, Document, stringify, YAMLMap, Pair, Scalar, YAMLSeq } from 'yaml';\nimport * as flat from 'flat';\nimport { stringifyEntitiesLight } from 'stringify-entities';\nimport { defaultHandlers } from 'mdast-util-to-markdown';\nimport { parseEntities } from 'parse-entities';\nimport { markdownLineEnding, markdownSpace, asciiAlpha, markdownLineEndingOrSpace, asciiAlphanumeric } from 'micromark-util-character';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { codeFenced } from 'micromark-core-commonmark';\n\nconst FRONTMATTER_DELIMITER_DEFAULT = \"---\";\nconst FRONTMATTER_DELIMITER_CODEBLOCK_STYLE = \"```yaml [props]\";\nconst LF = \"\\n\";\nconst CR = \"\\r\";\nfunction stringifyYAML(data, options) {\n  if (!data || !Object.keys(data).length) return \"\";\n  if (options?.preserveOrder && data.__order__) {\n    const newDoc = new Document();\n    newDoc.contents = buildFromOrdered(data.__order__);\n    return String(newDoc).trim();\n  }\n  Reflect.deleteProperty(data, \"__order__\");\n  data = flat.unflatten(data || {}, {});\n  return [\n    options?.prefix || \"\",\n    stringify(data, options).trim(),\n    options?.suffix || \"\"\n  ].join(\"\\n\").trim();\n}\nfunction stringifyFrontMatter(data, content = \"\", options) {\n  const str = stringifyYAML(data, {\n    prefix: FRONTMATTER_DELIMITER_DEFAULT,\n    suffix: FRONTMATTER_DELIMITER_DEFAULT,\n    ...options\n  });\n  return [str, \"\", content.trim()].join(\"\\n\").trim() + \"\\n\";\n}\nfunction stringifyCodeBlockProps(data, content = \"\", options) {\n  const str = stringifyYAML(data, {\n    prefix: FRONTMATTER_DELIMITER_CODEBLOCK_STYLE,\n    suffix: \"```\",\n    ...options\n  });\n  return [str, content.trim()].join(\"\\n\").trim() + \"\\n\";\n}\nfunction parseFrontMatter(content, options) {\n  let data = {};\n  if (content.startsWith(FRONTMATTER_DELIMITER_DEFAULT)) {\n    const idx = content.indexOf(LF + FRONTMATTER_DELIMITER_DEFAULT);\n    if (idx !== -1) {\n      const hasCarriageReturn = content[idx - 1] === CR;\n      const frontmatter = content.slice(4, idx - (hasCarriageReturn ? 1 : 0));\n      if (frontmatter) {\n        const document = parseDocument(frontmatter, options);\n        data = document.toJSON();\n        if (options?.preserveOrder) {\n          data.__order__ = extractOrdered(document.contents);\n        }\n        content = content.slice(idx + 4 + (hasCarriageReturn ? 1 : 0));\n      }\n    }\n  }\n  return {\n    content,\n    // unflatten frontmatter data. convert `parent.child` keys into `parent: { child: ... }`\n    data: flat.unflatten(data || {}, {})\n  };\n}\nfunction extractOrdered(valueNode) {\n  if (isMap(valueNode)) {\n    const map = [];\n    for (const item of valueNode.items) {\n      map.push([item.key.value, extractOrdered(item.value)]);\n    }\n    return { type: \"map\", value: map };\n  }\n  if (isSeq(valueNode)) {\n    return { type: \"seq\", value: valueNode.items.map((item) => extractOrdered(item)) };\n  }\n  if (isScalar(valueNode)) {\n    return { type: \"scalar\", value: valueNode.value };\n  }\n  return { type: \"scalar\", value: null };\n}\nfunction buildFromOrdered(orderedNode) {\n  if (orderedNode.type === \"map\") {\n    const map = new YAMLMap();\n    for (const [key, value] of orderedNode.value) {\n      map.items.push(new Pair(new Scalar(key), buildFromOrdered(value)));\n    }\n    return map;\n  }\n  if (orderedNode.type === \"seq\") {\n    const seq = new YAMLSeq();\n    for (const item of orderedNode.value) {\n      seq.items.push(buildFromOrdered(item));\n    }\n    return seq;\n  }\n  return new Scalar(orderedNode.value);\n}\n\nfunction track(options_) {\n  const options = options_ || {};\n  const now = options.now || {};\n  let lineShift = options.lineShift || 0;\n  let line = now.line || 1;\n  let column = now.column || 1;\n  return { move, current, shift };\n  function current() {\n    return { now: { line, column }, lineShift };\n  }\n  function shift(value) {\n    lineShift += value;\n  }\n  function move(value = \"\") {\n    const chunks = value.split(/\\r?\\n|\\r/g);\n    const tail = chunks[chunks.length - 1];\n    line += chunks.length - 1;\n    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;\n    return value;\n  }\n}\nfunction inlineContainerFlow(parent, context, safeOptions = {}) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  const tracker = track(safeOptions);\n  const results = [];\n  let index = -1;\n  indexStack.push(-1);\n  while (++index < children.length) {\n    const child = children[index];\n    indexStack[indexStack.length - 1] = index;\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          before: \"\",\n          after: \"\",\n          ...tracker.current()\n        })\n      )\n    );\n  }\n  indexStack.pop();\n  return results.join(\"\");\n}\nfunction containerFlow(parent, context, safeOptions = {}) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  const tracker = track(safeOptions);\n  const results = [];\n  let index = -1;\n  indexStack.push(-1);\n  while (++index < children.length) {\n    const child = children[index];\n    indexStack[indexStack.length - 1] = index;\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          before: \"\\n\",\n          after: \"\\n\",\n          ...tracker.current()\n        })\n      )\n    );\n    if (child.type !== \"list\") {\n      context.bulletLastUsed = void 0;\n    }\n    if (index < children.length - 1) {\n      results.push(tracker.move(between(child, children[index + 1])));\n    }\n  }\n  indexStack.pop();\n  return results.join(\"\");\n  function between(left, right) {\n    let index2 = context.join.length;\n    while (index2--) {\n      const result = context.join[index2](left, right, parent, context);\n      if (result === true || result === 1) {\n        break;\n      }\n      if (typeof result === \"number\") {\n        return \"\\n\".repeat(1 + result);\n      }\n      if (result === false) {\n        return \"\\n\\n<!---->\\n\\n\";\n      }\n    }\n    return \"\\n\\n\";\n  }\n}\nfunction containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  const results = [];\n  let index = -1;\n  let before = safeOptions.before;\n  indexStack.push(-1);\n  let tracker = track(safeOptions);\n  while (++index < children.length) {\n    const child = children[index];\n    let after;\n    indexStack[indexStack.length - 1] = index;\n    if (index + 1 < children.length) {\n      let handle = context.handle.handlers[children[index + 1].type];\n      if (handle && handle.peek) {\n        handle = handle.peek;\n      }\n      after = \"\";\n      if (handle) {\n        after = handle(\n          children[index + 1],\n          parent,\n          context,\n          {\n            before: \"\",\n            after: \"\",\n            ...tracker.current()\n          }\n        ).charAt(0);\n      }\n    } else {\n      after = safeOptions.after;\n    }\n    if (results.length > 0 && (before === \"\\r\" || before === \"\\n\") && child.type === \"html\") {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        \" \"\n      );\n      before = \" \";\n      tracker = track(safeOptions);\n      tracker.move(results.join(\"\"));\n    }\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    );\n    before = results[results.length - 1].slice(-1);\n  }\n  indexStack.pop();\n  return results.join(\"\");\n}\nfunction checkQuote(context) {\n  const marker = context.options.quote || '\"';\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      \"Cannot serialize title with `\" + marker + \"` for `options.quote`, expected `\\\"`, or `'`\"\n    );\n  }\n  return marker;\n}\n\nconst CONTAINER_NODE_TYPES = /* @__PURE__ */ new Set([\n  \"componentContainerSection\",\n  \"containerComponent\",\n  \"leafComponent\"\n]);\nconst NON_UNWRAPPABLE_TYPES = /* @__PURE__ */ new Set([\n  \"componentContainerSection\",\n  \"componentContainerDataSection\",\n  \"containerComponent\",\n  \"leafComponent\",\n  \"table\",\n  \"pre\",\n  \"code\",\n  \"textComponent\",\n  \"heading\"\n]);\nfunction convertHtmlEntitiesToChars(text) {\n  return text.replace(/&#x([0-9A-Fa-f]+);/g, (_, hexCode) => {\n    return String.fromCodePoint(Number.parseInt(hexCode, 16));\n  });\n}\n\nconst shortcut = /^[^\\t\\n\\r \"'.<=>`}]+$/;\nconst baseFence = 2;\nfunction compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before = (pattern.atBreak ? \"[\\\\r\\\\n][\\\\t ]*\" : \"\") + (pattern.before ? \"(?:\" + pattern.before + \")\" : \"\");\n    pattern._compiled = new RegExp(\n      (before ? \"(\" + before + \")\" : \"\") + (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? \"\\\\\" : \"\") + pattern.character + (pattern.after ? \"(?:\" + pattern.after + \")\" : \"\"),\n      \"g\"\n    );\n  }\n  return pattern._compiled;\n}\nconst toMarkdown = (opts = {}) => {\n  const applyAutomaticUnwrap = (node, _options) => {\n    if (!CONTAINER_NODE_TYPES.has(node.type)) {\n      return;\n    }\n    const isSafe = (type) => [\"paragraph\"].includes(type) || NON_UNWRAPPABLE_TYPES.has(type);\n    const safeChildrens = node.children.filter((child) => !isSafe(child.type));\n    if (safeChildrens.length === 0) {\n      return;\n    }\n    node.children = [\n      {\n        type: \"paragraph\",\n        children: safeChildrens\n      },\n      ...node.children.filter((child) => isSafe(child.type))\n    ];\n  };\n  const frontmatter = (node) => {\n    const entries = Object.entries(node.fmAttributes || {});\n    if (entries.length === 0) {\n      return \"\";\n    }\n    const attrs = entries.sort(([key1], [key2]) => key1.localeCompare(key2)).reduce((acc, [key, value2]) => {\n      if (key?.startsWith(\":\") && isValidJSON(value2)) {\n        try {\n          value2 = JSON.parse(value2);\n        } catch {\n        }\n        key = key.slice(1);\n      }\n      acc[key] = value2;\n      return acc;\n    }, {});\n    return \"\\n\" + (opts?.attributes?.yamlCodeBlock ? stringifyCodeBlockProps(attrs).trim() : stringifyFrontMatter(attrs).trim());\n  };\n  const processNode = (node) => {\n    if (opts.autoUnwrap) {\n      applyAutomaticUnwrap(node, typeof opts.autoUnwrap === \"boolean\" ? {} : opts.autoUnwrap);\n    }\n  };\n  function componentContainerSection(node, _, context) {\n    context.indexStack = context.stack;\n    processNode(node);\n    return `#${node.name}${attributes(node, context)}\n${content(node, context)}`.trim();\n  }\n  function textComponent(node, _, context) {\n    let value;\n    context.indexStack = context.stack;\n    const exit = context.enter(node.type);\n    if (node.name === \"span\") {\n      value = `[${content(node, context)}]${attributes(node, context)}`;\n    } else if (node.name === \"binding\") {\n      const attrs = node.attributes || {};\n      value = attrs.defaultValue ? `{{ ${attrs.value} || '${attrs.defaultValue}' }}` : `{{ ${attrs.value} }}`;\n    } else {\n      value = \":\" + (node.name || \"\") + label(node, context) + attributes(node, context);\n    }\n    exit();\n    return value;\n  }\n  let nest = 0;\n  function containerComponent(node, _, context) {\n    context.indexStack = context.stack;\n    const prefix = \":\".repeat(baseFence + nest);\n    nest += 1;\n    const exit = context.enter(node.type);\n    context.bulletLastUsed = void 0;\n    let value = prefix + (node.name || \"\") + label(node, context);\n    const defaultSlotChildren = node.children.filter((child) => child.type !== \"componentContainerSection\");\n    const slots = node.children.filter((child) => child.type === \"componentContainerSection\");\n    node.children = [\n      ...defaultSlotChildren,\n      ...slots\n    ];\n    node.fmAttributes = node.fmAttributes || {};\n    const attributesText = attributes(node, context);\n    const attributesEntries = Object.entries(node.attributes || {});\n    if ((value + attributesText).length > (opts?.attributes?.maxLength || 80) || Object.keys(node.fmAttributes).length > 0 || attributesEntries.length > 3 || attributesEntries.some(([_2, value2]) => typeof value2 === \"object\") || attributesText.match(/(=['\"][{[]|\\n)/) || node.children?.some((child) => child.type === \"componentContainerSection\")) {\n      Object.assign(node.fmAttributes, node.attributes);\n      node.attributes = [];\n    }\n    processNode(node);\n    value += attributes(node, context);\n    value += frontmatter(node);\n    let subvalue;\n    if (node.type === \"containerComponent\") {\n      subvalue = content(node, context);\n      if (subvalue) {\n        value += \"\\n\" + subvalue;\n      }\n      value += \"\\n\" + prefix;\n      if (nest > 1) {\n        value = value.split(\"\\n\").map((line) => line.length > 0 ? \"  \" + line : line).join(\"\\n\");\n      }\n    }\n    nest -= 1;\n    exit();\n    return value;\n  }\n  containerComponent.peek = function peekComponent() {\n    return \":\";\n  };\n  function label(node, context) {\n    let label2 = node;\n    if (node.type === \"containerComponent\") {\n      if (!inlineComponentLabel(node)) {\n        return \"\";\n      }\n      label2 = node.children[0];\n    }\n    const exit = context.enter(\"label\");\n    const subexit = context.enter(node.type + \"Label\");\n    const value = containerPhrasing(label2, context, { before: \"[\", after: \"]\" });\n    subexit();\n    exit();\n    return value ? \"[\" + value + \"]\" : \"\";\n  }\n  const isValidJSON = (str) => {\n    try {\n      JSON.parse(str);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  function attributes(node, context) {\n    const quote = checkQuote(context);\n    const subset = node.type === \"textComponent\" ? [quote] : [quote, \"\\n\", \"\\r\"];\n    const attributes2 = node.attributes || {};\n    const attrs = opts.attributes?.preserveOrder && attributes2.__order__ ? attributes2.__order__?.value : Object.entries(attributes2).sort(([key1], [key2]) => key1.localeCompare(key2));\n    const values = [];\n    let id;\n    let classesFull = \"\";\n    let classes = \"\";\n    let index;\n    for (const attr of attrs) {\n      const key = attr[0];\n      let value = attr[1];\n      if (attr[1] != null) {\n        value = String(attr[1]);\n        if (key === \"id\") {\n          id = shortcut.test(value) ? \"#\" + value : quoted(\"id\", value);\n        } else if (key === \"class\" || key === \"className\") {\n          value = Array.isArray(attrs[key]) ? attrs[key].join(\" \") : value;\n          value = value.split(/[\\t\\n\\r ]+/g).filter(Boolean);\n          classesFull = [];\n          classes = [];\n          index = -1;\n          while (++index < value.length) {\n            (shortcut.test(value[index]) ? classes : classesFull).push(value[index]);\n          }\n          classesFull = classesFull.length ? quoted(\"class\", classesFull.join(\" \")) : \"\";\n          classes = classes.length ? \".\" + classes.join(\".\") : \"\";\n        } else if (key.startsWith(\":\") && value === \"true\") {\n          values.push(key.slice(1));\n        } else if (key.startsWith(\":\") && isValidJSON(value)) {\n          values.push(`${key}='${value.replace(/([^/])'/g, \"$1\\\\'\")}'`);\n        } else if (typeof attr[1] === \"object\") {\n          values.push(quoted(key, JSON.stringify(value)));\n        } else {\n          values.push(quoted(key, value));\n        }\n      }\n    }\n    if (classesFull) {\n      values.unshift(classesFull);\n    }\n    if (classes) {\n      values.unshift(classes);\n    }\n    if (id) {\n      values.unshift(id);\n    }\n    return values.length ? \"{\" + values.join(\" \") + \"}\" : \"\";\n    function quoted(key, value) {\n      return key + \"=\" + quote + stringifyEntitiesLight(value, { subset }) + quote;\n    }\n  }\n  function content(node, context) {\n    const content2 = inlineComponentLabel(node) ? Object.assign({}, node, { children: node.children.slice(1) }) : node;\n    let result = node.type === \"textComponent\" ? inlineContainerFlow(content2, context) : containerFlow(content2, context);\n    if (result.includes(\"&#x\")) {\n      result = convertHtmlEntitiesToChars(result);\n    }\n    return result;\n  }\n  function inlineComponentLabel(node) {\n    return node.children && node.children[0] && node.children[0].data && node.children[0].data.componentLabel;\n  }\n  return {\n    compilePattern,\n    unsafe: [\n      {\n        character: \"\\r\",\n        inConstruct: [\"leafComponentLabel\", \"containerComponentLabel\"]\n      },\n      {\n        character: \"\\n\",\n        inConstruct: [\"leafComponentLabel\", \"containerComponentLabel\"]\n      },\n      {\n        before: \"[^:]\",\n        character: \":\",\n        after: \"[A-Za-z]\",\n        inConstruct: [\"phrasing\"]\n      },\n      { atBreak: true, character: \":\", after: \":\" }\n    ],\n    handlers: {\n      containerComponent,\n      textComponent,\n      componentContainerSection,\n      image: (node, _, state, info) => {\n        return defaultHandlers.image(node, _, state, info) + attributes(node, state);\n      },\n      link: (node, _, state, info) => {\n        const andPattern = state.unsafe.find((pattern) => pattern.character === \"&\");\n        const defaultNotInConstruct = andPattern?.notInConstruct || [];\n        if (andPattern) {\n          andPattern.notInConstruct = \"destinationRaw\";\n        }\n        const result = defaultHandlers.link(node, _, state, info) + attributes(node, state);\n        if (andPattern) {\n          andPattern.notInConstruct = defaultNotInConstruct;\n        }\n        return result;\n      },\n      linkReference: (node, _, state, info) => {\n        return defaultHandlers.linkReference(node, _, state, info) + attributes(node, state);\n      },\n      strong: (node, _, state, info) => {\n        return defaultHandlers.strong(node, _, state, info) + attributes(node, state);\n      },\n      inlineCode: (node, _, state) => {\n        state.compilePattern = state.compilePattern || compilePattern;\n        return defaultHandlers.inlineCode(node, _, state) + attributes(node, state);\n      },\n      emphasis: (node, _, state, info) => {\n        return defaultHandlers.emphasis(node, _, state, info) + attributes(node, state);\n      }\n    }\n  };\n};\n\nconst fromMarkdown = (opts = {}) => {\n  const canContainEols = [\"textComponent\"];\n  const applyYamlCodeBlockProps = (node) => {\n    const firstSection = node.children[0];\n    if (firstSection && firstSection.children?.length && firstSection.children[0]?.type === \"code\" && firstSection.children[0]?.lang === \"yaml\" && firstSection.children[0]?.meta === \"[props]\") {\n      node.rawData = firstSection.children[0].value;\n      node.mdc = node.mdc || {};\n      node.mdc.codeBlockProps = true;\n      firstSection.children.splice(0, 1);\n    }\n  };\n  const applyAutomaticUnwrap = (node, _options) => {\n    if (!CONTAINER_NODE_TYPES.has(node.type)) {\n      return;\n    }\n    const nonSlotChildren = node.children.filter((child2) => child2.type !== \"componentContainerSection\");\n    if (nonSlotChildren.length !== 1) {\n      return;\n    }\n    const child = nonSlotChildren[0];\n    if (child.type !== \"paragraph\") {\n      return;\n    }\n    const childIndex = node.children.indexOf(child);\n    node.children.splice(childIndex, 1, ...child?.children || []);\n  };\n  const processNode = (node) => {\n    if (opts.attributes?.yamlCodeBlock) {\n      applyYamlCodeBlockProps(node);\n    }\n    if (opts.autoUnwrap) {\n      applyAutomaticUnwrap(node, typeof opts.autoUnwrap === \"boolean\" ? {} : opts.autoUnwrap);\n    }\n  };\n  const enter = {\n    componentContainer: enterContainer,\n    componentContainerSection: enterContainerSection,\n    componentContainerDataSection: enterContainerDataSection,\n    componentContainerAttributes: enterAttributes,\n    componentContainerLabel: enterContainerLabel,\n    bindingContent: enterBindingContent,\n    componentLeaf: enterLeaf,\n    componentLeafAttributes: enterAttributes,\n    componentText: enterText,\n    textSpan: enterTextSpan,\n    componentTextAttributes: enterAttributes\n  };\n  const exit = {\n    bindingContent: exitBindingContent,\n    componentContainerSectionTitle: exitContainerSectionTitle,\n    listUnordered: conditionalExit,\n    listOrdered: conditionalExit,\n    listItem: conditionalExit,\n    componentContainerSection: exitContainerSection,\n    componentContainerDataSection: exitContainerDataSection,\n    componentContainer: exitContainer,\n    componentContainerAttributeClassValue: exitAttributeClassValue,\n    componentContainerAttributeIdValue: exitAttributeIdValue,\n    componentContainerAttributeName: exitAttributeName,\n    componentContainerAttributeValue: exitAttributeValue,\n    componentContainerAttributes: exitAttributes,\n    componentContainerLabel: exitContainerLabel,\n    componentContainerName,\n    componentContainerAttributeInitializerMarker() {\n      const attributes = this.data.componentAttributes;\n      attributes[attributes.length - 1][1] = \"\";\n    },\n    componentLeaf: exitToken,\n    componentLeafAttributeClassValue: exitAttributeClassValue,\n    componentLeafAttributeIdValue: exitAttributeIdValue,\n    componentLeafAttributeName: exitAttributeName,\n    componentLeafAttributeValue: exitAttributeValue,\n    componentLeafAttributes: exitAttributes,\n    componentLeafName: exitName,\n    componentText: exitToken,\n    textSpan: exitToken,\n    componentTextAttributeClassValue: exitAttributeClassValue,\n    componentTextAttributeIdValue: exitAttributeIdValue,\n    componentTextAttributeName: exitAttributeName,\n    componentTextAttributeValue: exitAttributeValue,\n    componentTextAttributes: exitAttributes,\n    componentTextName: componentContainerName\n  };\n  function enterBindingContent(token) {\n    const regex = /([^|]*)(?:\\|\\|\\s*'(.*)')?/;\n    const values = regex.exec(this.sliceSerialize(token));\n    this.enter({\n      type: \"textComponent\",\n      name: \"binding\",\n      attributes: {\n        value: values?.[1]?.trim(),\n        defaultValue: values?.[2]\n      }\n    }, token);\n  }\n  function exitBindingContent(token) {\n    this.exit(token);\n  }\n  function enterContainer(token) {\n    enterToken.call(this, \"containerComponent\", token);\n  }\n  function exitContainer(token) {\n    const container = this.stack[this.stack.length - 1];\n    if (container.children.length > 1) {\n      const dataSection = container.children.find((child) => child.rawData);\n      container.rawData = dataSection?.rawData;\n    }\n    processNode(container);\n    container.children = container.children.flatMap((child) => {\n      if (child.rawData) {\n        return [];\n      }\n      if (child.name === \"default\" && Object.keys(child.attributes).length === 0 || !child.name) {\n        if (child.mdc?.unwrapped) {\n          container.mdc = container.mdc || {};\n          container.mdc.unwrapped = child.mdc?.unwrapped;\n        }\n        return child.children;\n      }\n      child.data = {\n        hName: \"component-slot\",\n        hProperties: {\n          ...child.attributes,\n          [`v-slot:${child.name}`]: \"\"\n        }\n      };\n      return child;\n    });\n    this.exit(token);\n  }\n  function enterContainerSection(token) {\n    enterToken.call(this, \"componentContainerSection\", token);\n  }\n  function enterContainerDataSection(token) {\n    enterToken.call(this, \"componentContainerDataSection\", token);\n  }\n  function exitContainerSection(token) {\n    const section = this.stack[this.stack.length - 1];\n    attemptClosingOpenListSection.call(this, section);\n    processNode(section);\n    this.exit(token);\n  }\n  function exitContainerDataSection(token) {\n    let section = this.stack[this.stack.length - 1];\n    section = attemptClosingOpenListSection.call(this, section);\n    if (section.type === \"componentContainerDataSection\") {\n      section.rawData = this.sliceSerialize(token);\n      this.exit(token);\n    }\n  }\n  function exitContainerSectionTitle(token) {\n    this.stack[this.stack.length - 1].name = this.sliceSerialize(token)?.trim();\n  }\n  function enterLeaf(token) {\n    enterToken.call(this, \"leafComponent\", token);\n  }\n  function enterTextSpan(token) {\n    this.enter({ type: \"textComponent\", name: \"span\", attributes: {}, children: [] }, token);\n  }\n  function enterText(token) {\n    enterToken.call(this, \"textComponent\", token);\n  }\n  function enterToken(type, token) {\n    this.enter({ type, name: \"\", attributes: {}, children: [] }, token);\n  }\n  function componentContainerName(token) {\n    this.stack[this.stack.length - 1].name = kebabCase(this.sliceSerialize(token));\n  }\n  function exitName(token) {\n    this.stack[this.stack.length - 1].name = this.sliceSerialize(token);\n  }\n  function enterContainerLabel(token) {\n    this.enter({ type: \"paragraph\", data: { componentLabel: true }, children: [] }, token);\n  }\n  function exitContainerLabel(token) {\n    this.exit(token);\n  }\n  function enterAttributes() {\n    this.data.componentAttributes = [];\n    this.buffer();\n  }\n  function exitAttributeIdValue(token) {\n    this.data.componentAttributes.push([\"id\", parseEntities(this.sliceSerialize(token))]);\n  }\n  function exitAttributeClassValue(token) {\n    this.data.componentAttributes.push([\"class\", parseEntities(this.sliceSerialize(token))]);\n  }\n  function exitAttributeValue(token) {\n    const attributes = this.data.componentAttributes;\n    const lastAttribute = attributes[attributes.length - 1];\n    lastAttribute[1] = (typeof lastAttribute[1] === \"string\" ? lastAttribute[1] : \"\") + parseEntities(this.sliceSerialize(token));\n  }\n  function exitAttributeName(token) {\n    this.data.componentAttributes.push([this.sliceSerialize(token), true]);\n  }\n  function exitAttributes() {\n    const attributes = this.data.componentAttributes;\n    const cleaned = {};\n    let index = -1;\n    let attribute;\n    while (++index < attributes.length) {\n      attribute = attributes[index];\n      const name = kebabCase(attribute[0]);\n      if (name === \"class\" && cleaned.class) {\n        cleaned.class += \" \" + attribute[1];\n      } else {\n        cleaned[name] = attribute[1];\n      }\n    }\n    this.data.componentAttributes = attributes;\n    this.resume();\n    let stackTop = this.stack[this.stack.length - 1];\n    if (stackTop?.type !== \"textComponent\" || stackTop?.name === \"span\") {\n      while (!stackTop?.position?.end && stackTop.children?.length > 0) {\n        stackTop = stackTop.children[stackTop.children.length - 1];\n      }\n    }\n    stackTop.attributes = opts.attributes?.preserveOrder ? { __order__: { type: \"map\", value: attributes }, ...cleaned } : cleaned;\n  }\n  function exitToken(token) {\n    this.exit(token);\n  }\n  function conditionalExit(token) {\n    const [section] = this.tokenStack[this.tokenStack.length - 1];\n    if (section.type === token.type) {\n      this.exit(token);\n    }\n  }\n  function attemptClosingOpenListSection(section) {\n    while (section.type === \"listItem\" || section.type === \"list\") {\n      const [stackToken] = this.tokenStack[this.tokenStack.length - 1];\n      this.exit(stackToken);\n      section = this.stack[this.stack.length - 1];\n    }\n    return section;\n  }\n  return {\n    canContainEols,\n    enter,\n    exit\n  };\n};\n\nconst ContainerSequenceSize = 2;\nconst SectionSequenceSize = 3;\nconst slotSeparatorCode = 35;\nconst slotSeparatorLength = 1;\nconst Codes = {\n  /**\n   * null\n   */\n  EOF: null,\n  /**\n   * ' '\n   */\n  space: 32,\n  /**\n   * '\"'\n   */\n  quotationMark: 34,\n  /**\n   * '#'\n   */\n  hash: 35,\n  /**\n   * ' ' '\n   */\n  apostrophe: 39,\n  /**\n   * '('\n   */\n  openingParentheses: 40,\n  /**\n   * '*'\n   */\n  star: 42,\n  /**\n   * '-'\n   */\n  dash: 45,\n  /**\n   * '.'\n   */\n  dot: 46,\n  /**\n   * ':'\n   */\n  colon: 58,\n  /**\n   * '<'\n   */\n  LessThan: 60,\n  /**\n   * '='\n   */\n  equals: 61,\n  /**\n   * '>'\n   */\n  greaterThan: 62,\n  /**\n   * 'X'\n   */\n  uppercaseX: 88,\n  /**\n   * '['\n   */\n  openingSquareBracket: 91,\n  /**\n   * '\\'\n   */\n  backSlash: 92,\n  /**\n   * ']'\n   */\n  closingSquareBracket: 93,\n  /**\n   * '_'\n   */\n  underscore: 95,\n  /**\n   * '`'\n   */\n  backTick: 96,\n  /**\n   * 'x'\n   */\n  lowercaseX: 120,\n  /**\n   * '{'\n   */\n  openingCurlyBracket: 123,\n  /**\n   * '}'\n   */\n  closingCurlyBracket: 125,\n  /**\n   * '~'\n   */\n  tilde: 126\n};\n\nfunction createLabel(effects, ok, nok, type, markerType, stringType, disallowEol) {\n  let size = 0;\n  let balance = 0;\n  return start;\n  function start(code) {\n    if (code !== Codes.openingSquareBracket) {\n      throw new Error(\"expected `[`\");\n    }\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    return afterStart;\n  }\n  function afterStart(code) {\n    if (code === Codes.closingSquareBracket) {\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n    effects.enter(stringType);\n    return atBreak(code);\n  }\n  function atBreak(code) {\n    if (code === Codes.EOF || size > 999) {\n      return nok(code);\n    }\n    if (code === Codes.closingSquareBracket && !balance--) {\n      return atClosingBrace(code);\n    }\n    if (markdownLineEnding(code)) {\n      if (disallowEol) {\n        return nok(code);\n      }\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return atBreak;\n    }\n    effects.enter(\"chunkText\", { contentType: \"text\" });\n    return label(code);\n  }\n  function label(code) {\n    if (code === Codes.EOF || markdownLineEnding(code) || size > 999) {\n      effects.exit(\"chunkText\");\n      return atBreak(code);\n    }\n    if (code === Codes.openingSquareBracket && ++balance > 3) {\n      return nok(code);\n    }\n    if (code === Codes.closingSquareBracket && !balance--) {\n      effects.exit(\"chunkText\");\n      return atClosingBrace(code);\n    }\n    effects.consume(code);\n    return code === Codes.backSlash ? labelEscape : label;\n  }\n  function atClosingBrace(code) {\n    effects.exit(stringType);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.exit(type);\n    return ok;\n  }\n  function labelEscape(code) {\n    if (code === Codes.openingSquareBracket || code === Codes.backSlash || code === Codes.closingSquareBracket) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n    return label(code);\n  }\n}\n\nconst label$2 = { tokenize: tokenizeLabel$2, partial: true };\nconst gfmCheck = { tokenize: checkGfmTaskCheckbox, partial: true };\nconst doubleBracketCheck = { tokenize: checkDoubleBracket, partial: true };\nfunction tokenize$6(effects, ok, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code !== Codes.openingSquareBracket) {\n      throw new Error(\"expected `[`\");\n    }\n    if (self.previous === Codes.EOF && self._gfmTasklistFirstContentOfListItem) {\n      return effects.check(gfmCheck, nok, attemptLabel)(code);\n    }\n    if (self.previous === Codes.openingSquareBracket) {\n      return nok(code);\n    }\n    return effects.check(doubleBracketCheck, nok, attemptLabel)(code);\n  }\n  function attemptLabel(code) {\n    effects.enter(\"textSpan\");\n    return effects.attempt(label$2, exit, nok)(code);\n  }\n  function exit(code) {\n    if (code === Codes.openingParentheses || code === Codes.openingSquareBracket) {\n      return nok(code);\n    }\n    return exitOK(code);\n  }\n  function exitOK(code) {\n    effects.exit(\"textSpan\");\n    return ok(code);\n  }\n}\nfunction tokenizeLabel$2(effects, ok, nok) {\n  return createLabel(effects, ok, nok, \"componentTextLabel\", \"componentTextLabelMarker\", \"componentTextLabelString\");\n}\nconst tokenizeSpan = {\n  tokenize: tokenize$6\n};\nfunction checkGfmTaskCheckbox(effects, ok, nok) {\n  return enter;\n  function enter(code) {\n    effects.enter(\"formGfmTaskCheckbox\");\n    effects.consume(code);\n    return check;\n  }\n  function check(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return check;\n    }\n    if (code === Codes.uppercaseX || code === Codes.lowercaseX) {\n      effects.consume(code);\n      return check;\n    }\n    if (code === Codes.closingSquareBracket) {\n      effects.exit(\"formGfmTaskCheckbox\");\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\nfunction checkDoubleBracket(effects, ok, nok) {\n  return enter;\n  function enter(code) {\n    effects.enter(\"doubleBracket\");\n    effects.consume(code);\n    return check;\n  }\n  function check(code) {\n    if (code !== Codes.openingSquareBracket) {\n      return nok(code);\n    }\n    effects.exit(\"doubleBracket\");\n    return ok(code);\n  }\n}\n\nfunction createAttributes(effects, ok, nok, attributesType, attributesMarkerType, attributeType, attributeIdType, attributeClassType, attributeNameType, attributeInitializerType, attributeValueLiteralType, attributeValueType, attributeValueMarker, attributeValueData, disallowEol) {\n  let type;\n  let marker;\n  let isBindAttribute = false;\n  return start;\n  function start(code) {\n    effects.enter(attributesType);\n    effects.enter(attributesMarkerType);\n    effects.consume(code);\n    effects.exit(attributesMarkerType);\n    return between;\n  }\n  function between(code) {\n    if (code === Codes.hash) {\n      type = attributeIdType;\n      return shortcutStart(code);\n    }\n    if (code === Codes.dot) {\n      type = attributeClassType;\n      return shortcutStart(code);\n    }\n    if (code === Codes.colon || code === Codes.underscore || asciiAlpha(code)) {\n      effects.enter(attributeType);\n      effects.enter(attributeNameType);\n      effects.consume(code);\n      isBindAttribute = code === Codes.colon;\n      return code === Codes.colon ? bindAttributeName : name;\n    }\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, between, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, between)(code);\n    }\n    return end(code);\n  }\n  function shortcutStart(code) {\n    effects.enter(attributeType);\n    effects.enter(type);\n    effects.enter(type + \"Marker\");\n    effects.consume(code);\n    effects.exit(type + \"Marker\");\n    return shortcutStartAfter;\n  }\n  function shortcutStartAfter(code) {\n    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.hash || code === Codes.apostrophe || code === Codes.dot || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick || code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    effects.enter(type + \"Value\");\n    effects.consume(code);\n    return shortcut;\n  }\n  function shortcut(code) {\n    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.apostrophe || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick) {\n      return nok(code);\n    }\n    if (code === Codes.dot || code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {\n      effects.exit(type + \"Value\");\n      effects.exit(type);\n      effects.exit(attributeType);\n      return between(code);\n    }\n    effects.consume(code);\n    return shortcut;\n  }\n  function bindAttributeName(code) {\n    if (code === Codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return bindAttributeName;\n    }\n    effects.exit(attributeNameType);\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, bindAttributeNameAfter, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, bindAttributeNameAfter)(code);\n    }\n    return bindAttributeNameAfter(code);\n  }\n  function bindAttributeNameAfter(code) {\n    if (code === Codes.equals) {\n      effects.enter(attributeInitializerType);\n      effects.consume(code);\n      effects.exit(attributeInitializerType);\n      return valueBefore;\n    }\n    effects.exit(attributeType);\n    return nok(code);\n  }\n  function name(code) {\n    if (code === Codes.dash || code === Codes.dot || code === Codes.colon || code === Codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return name;\n    }\n    effects.exit(attributeNameType);\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, nameAfter, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, nameAfter)(code);\n    }\n    return nameAfter(code);\n  }\n  function nameAfter(code) {\n    if (code === Codes.equals) {\n      effects.enter(attributeInitializerType);\n      effects.consume(code);\n      effects.exit(attributeInitializerType);\n      return valueBefore;\n    }\n    effects.exit(attributeType);\n    return between(code);\n  }\n  function valueBefore(code) {\n    if (code === Codes.EOF || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick || code === Codes.closingCurlyBracket || disallowEol && markdownLineEnding(code)) {\n      return nok(code);\n    }\n    if (code === Codes.quotationMark || code === Codes.apostrophe) {\n      effects.enter(attributeValueLiteralType);\n      effects.enter(attributeValueMarker);\n      effects.consume(code);\n      effects.exit(attributeValueMarker);\n      marker = code;\n      return valueQuotedStart;\n    }\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, valueBefore, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, valueBefore)(code);\n    }\n    effects.enter(attributeValueType);\n    effects.enter(attributeValueData);\n    effects.consume(code);\n    marker = void 0;\n    return valueUnquoted;\n  }\n  function valueUnquoted(code) {\n    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.apostrophe || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick) {\n      return nok(code);\n    }\n    if (code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {\n      effects.exit(attributeValueData);\n      effects.exit(attributeValueType);\n      effects.exit(attributeType);\n      return between(code);\n    }\n    effects.consume(code);\n    return valueUnquoted;\n  }\n  function valueQuotedStart(code) {\n    if (code === marker) {\n      effects.enter(attributeValueMarker);\n      effects.consume(code);\n      effects.exit(attributeValueMarker);\n      effects.exit(attributeValueLiteralType);\n      effects.exit(attributeType);\n      return valueQuotedAfter;\n    }\n    effects.enter(attributeValueType);\n    return valueQuotedBetween(code);\n  }\n  function valueQuotedBetween(code) {\n    if (code === marker) {\n      effects.exit(attributeValueType);\n      return valueQuotedStart(code);\n    }\n    if (code === Codes.EOF) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      return disallowEol ? nok(code) : factoryWhitespace(effects, valueQuotedBetween)(code);\n    }\n    effects.enter(attributeValueData);\n    effects.consume(code);\n    return valueQuoted;\n  }\n  function valueQuoted(code) {\n    if (isBindAttribute && code === Codes.backSlash) {\n      effects.exit(attributeValueData);\n      effects.exit(attributeValueType);\n      effects.enter(\"escapeCharacter\");\n      effects.consume(code);\n      effects.exit(\"escapeCharacter\");\n      effects.enter(attributeValueType);\n      effects.enter(attributeValueData);\n      return valueQuotedEscape;\n    }\n    if (code === marker || code === Codes.EOF || markdownLineEnding(code)) {\n      effects.exit(attributeValueData);\n      return valueQuotedBetween(code);\n    }\n    effects.consume(code);\n    return valueQuoted;\n  }\n  function valueQuotedEscape(code) {\n    effects.consume(code);\n    return valueQuoted;\n  }\n  function valueQuotedAfter(code) {\n    return code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code) ? between(code) : end(code);\n  }\n  function end(code) {\n    if (code === Codes.closingCurlyBracket) {\n      effects.enter(attributesMarkerType);\n      effects.consume(code);\n      effects.exit(attributesMarkerType);\n      effects.exit(attributesType);\n      return ok;\n    }\n    return nok(code);\n  }\n}\n\nconst attributes$2 = { tokenize: tokenizeAttributes$2, partial: true };\nconst validEvents = [\n  /**\n   * Span\n   */\n  \"textSpan\",\n  /**\n   * Bold & Italic\n   */\n  \"attentionSequence\",\n  /**\n   * Inline Code\n   */\n  \"codeText\",\n  /**\n   * Link\n   */\n  \"link\",\n  /**\n   * Image\n   */\n  \"image\"\n];\nfunction tokenize$5(effects, ok, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code !== Codes.openingCurlyBracket) {\n      throw new Error(\"expected `{`\");\n    }\n    const event = self.events[self.events.length - 1];\n    if (markdownLineEnding(self.previous) || !event || !validEvents.includes(event[1].type)) {\n      return nok(code);\n    }\n    return effects.attempt(attributes$2, ok, nok)(code);\n  }\n}\nfunction tokenizeAttributes$2(effects, ok, nok) {\n  return createAttributes(\n    effects,\n    ok,\n    nok,\n    \"componentTextAttributes\",\n    \"componentTextAttributesMarker\",\n    \"componentTextAttribute\",\n    \"componentTextAttributeId\",\n    \"componentTextAttributeClass\",\n    \"componentTextAttributeName\",\n    \"componentTextAttributeInitializerMarker\",\n    \"componentTextAttributeValueLiteral\",\n    \"componentTextAttributeValue\",\n    \"componentTextAttributeValueMarker\",\n    \"componentTextAttributeValueData\"\n  );\n}\nconst tokenizeAttribute = {\n  tokenize: tokenize$5\n};\n\nfunction attempClose(effects, ok, nok) {\n  return start;\n  function start(code) {\n    if (code !== Codes.closingCurlyBracket) {\n      return nok(code);\n    }\n    effects.exit(\"bindingContent\");\n    effects.enter(\"bindingFence\");\n    effects.consume(code);\n    return secondBracket;\n  }\n  function secondBracket(code) {\n    if (code !== Codes.closingCurlyBracket) {\n      return nok(code);\n    }\n    effects.consume(code);\n    effects.exit(\"bindingFence\");\n    return ok;\n  }\n}\nfunction tokenize$4(effects, ok, nok) {\n  return start;\n  function start(code) {\n    if (code !== Codes.openingCurlyBracket) {\n      throw new Error(\"expected `{`\");\n    }\n    effects.enter(\"bindingFence\");\n    effects.consume(code);\n    return secondBracket;\n  }\n  function secondBracket(code) {\n    if (code !== Codes.openingCurlyBracket) {\n      return nok(code);\n    }\n    effects.consume(code);\n    effects.exit(\"bindingFence\");\n    effects.enter(\"bindingContent\");\n    return content;\n  }\n  function content(code) {\n    if (code === Codes.closingCurlyBracket) {\n      return effects.attempt({ tokenize: attempClose, partial: true }, close, (code2) => {\n        effects.consume(code2);\n        return content;\n      })(code);\n    }\n    effects.consume(code);\n    return content;\n  }\n  function close(code) {\n    return ok(code);\n  }\n}\nconst tokenizeBinding = {\n  tokenize: tokenize$4\n};\n\nfunction createName(effects, ok, nok, nameType) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (asciiAlpha(code)) {\n      effects.enter(nameType);\n      effects.consume(code);\n      return name;\n    }\n    return nok(code);\n  }\n  function name(code) {\n    if (code === Codes.dash || code === Codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return name;\n    }\n    effects.exit(nameType);\n    return self.previous === Codes.underscore ? nok(code) : ok(code);\n  }\n}\n\nconst label$1 = { tokenize: tokenizeLabel$1, partial: true };\nconst attributes$1 = { tokenize: tokenizeAttributes$1, partial: true };\nfunction previous(code) {\n  return code !== Codes.colon || this.events[this.events.length - 1]?.[1]?.type === \"characterEscape\";\n}\nfunction tokenize$3(effects, ok, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code !== Codes.colon) {\n      throw new Error(\"expected `:`\");\n    }\n    if (self.previous !== null && !markdownLineEndingOrSpace(self.previous) && ![Codes.openingSquareBracket, Codes.star, Codes.underscore, Codes.openingParentheses].includes(self.previous)) {\n      return nok(code);\n    }\n    if (!previous.call(self, self.previous)) {\n      throw new Error(\"expected correct previous\");\n    }\n    effects.enter(\"componentText\");\n    effects.enter(\"componentTextMarker\");\n    effects.consume(code);\n    effects.exit(\"componentTextMarker\");\n    return createName.call(self, effects, afterName, nok, \"componentTextName\");\n  }\n  function afterName(code) {\n    if (code === Codes.colon) {\n      return nok(code);\n    }\n    if (code === Codes.openingSquareBracket) {\n      return effects.attempt(label$1, afterLabel, afterLabel)(code);\n    }\n    if (code === Codes.openingCurlyBracket) {\n      return effects.attempt(attributes$1, afterAttributes, afterAttributes)(code);\n    }\n    return exit(code);\n  }\n  function afterAttributes(code) {\n    if (code === Codes.openingSquareBracket) {\n      return effects.attempt(label$1, afterLabel, afterLabel)(code);\n    }\n    return exit(code);\n  }\n  function afterLabel(code) {\n    if (code === Codes.openingCurlyBracket) {\n      return effects.attempt(attributes$1, exit, exit)(code);\n    }\n    return exit(code);\n  }\n  function exit(code) {\n    effects.exit(\"componentText\");\n    return ok(code);\n  }\n}\nfunction tokenizeLabel$1(effects, ok, nok) {\n  return createLabel(effects, ok, nok, \"componentTextLabel\", \"componentTextLabelMarker\", \"componentTextLabelString\");\n}\nfunction tokenizeAttributes$1(effects, ok, nok) {\n  return createAttributes(\n    effects,\n    ok,\n    nok,\n    \"componentTextAttributes\",\n    \"componentTextAttributesMarker\",\n    \"componentTextAttribute\",\n    \"componentTextAttributeId\",\n    \"componentTextAttributeClass\",\n    \"componentTextAttributeName\",\n    \"componentTextAttributeInitializerMarker\",\n    \"componentTextAttributeValueLiteral\",\n    \"componentTextAttributeValue\",\n    \"componentTextAttributeValueMarker\",\n    \"componentTextAttributeValueData\"\n  );\n}\nconst tokenizeInline = {\n  tokenize: tokenize$3,\n  previous\n};\n\nfunction sizeChunks(chunks) {\n  let index = -1;\n  let size = 0;\n  while (++index < chunks.length) {\n    size += typeof chunks[index] === \"string\" ? chunks[index].length : 1;\n  }\n  return size;\n}\nfunction prefixSize(events, type) {\n  const tail = events[events.length - 1];\n  if (!tail || tail[1].type !== type) {\n    return 0;\n  }\n  return sizeChunks(tail[2].sliceStream(tail[1]));\n}\nfunction linePrefixSize(events) {\n  let size = 0;\n  let index = events.length - 1;\n  let tail = events[index];\n  while (index >= 0 && tail && tail[1].type === \"linePrefix\" && tail[0] === \"exit\") {\n    size += sizeChunks(tail[2].sliceStream(tail[1]));\n    index -= 1;\n    tail = events[index];\n  }\n  return size;\n}\nconst useTokenState = (tokenName) => {\n  const token = {\n    isOpen: false,\n    /**\n     * Enter into token, close previous open token if any\n     */\n    enter: (effects) => {\n      const initialState = token.isOpen;\n      token.exit(effects);\n      effects.enter(tokenName);\n      token.isOpen = true;\n      return () => {\n        token.isOpen = initialState;\n      };\n    },\n    /**\n     * Enter into token only once, if token is already open, do nothing\n     */\n    enterOnce: (effects) => {\n      const initialState = token.isOpen;\n      if (!token.isOpen) {\n        effects.enter(tokenName);\n        token.isOpen = true;\n      }\n      return () => {\n        token.isOpen = initialState;\n      };\n    },\n    /**\n     * Exit from token if it is open\n     */\n    exit: (effects) => {\n      const initialState = token.isOpen;\n      if (token.isOpen) {\n        effects.exit(tokenName);\n        token.isOpen = false;\n      }\n      return () => {\n        token.isOpen = initialState;\n      };\n    }\n  };\n  return token;\n};\nconst tokenizeCodeFence = { tokenize: checkCodeFenced, partial: true };\nfunction checkCodeFenced(effects, ok, nok) {\n  let backTickCount = 0;\n  return start;\n  function start(code) {\n    effects.enter(\"codeFenced\");\n    return after(code);\n  }\n  function after(code) {\n    if (code === Codes.backTick || code === Codes.tilde) {\n      backTickCount++;\n      effects.consume(code);\n      return after;\n    }\n    effects.exit(\"codeFenced\");\n    if (backTickCount >= 3) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\nfunction tokenizeFrontMatter(effects, ok, _nok, next, initialPrefix) {\n  let previous;\n  return effects.attempt({\n    tokenize: tokenizeDataSection,\n    partial: true\n  }, dataSectionOpen, next);\n  function tokenizeDataSection(effects2, ok2, nok) {\n    const self = this;\n    let size = 0;\n    let sectionIndentSize = 0;\n    return closingPrefixAfter;\n    function dataLineFirstSpaces(code) {\n      if (markdownSpace(code)) {\n        effects2.consume(code);\n        sectionIndentSize += 1;\n        return dataLineFirstSpaces;\n      }\n      effects2.exit(\"space\");\n      return closingPrefixAfter(code);\n    }\n    function closingPrefixAfter(code) {\n      if (markdownSpace(code)) {\n        effects2.enter(\"space\");\n        return dataLineFirstSpaces(code);\n      }\n      if (sectionIndentSize === 0) {\n        sectionIndentSize = linePrefixSize(self.events);\n      }\n      effects2.enter(\"componentContainerSectionSequence\");\n      return closingSectionSequence(code);\n    }\n    function closingSectionSequence(code) {\n      if (code === Codes.dash || markdownSpace(code)) {\n        effects2.consume(code);\n        size++;\n        return closingSectionSequence;\n      }\n      if (size < SectionSequenceSize) {\n        return nok(code);\n      }\n      if (sectionIndentSize !== initialPrefix) {\n        return nok(code);\n      }\n      if (!markdownLineEnding(code)) {\n        return nok(code);\n      }\n      effects2.exit(\"componentContainerSectionSequence\");\n      return factorySpace(effects2, ok2, \"whitespace\")(code);\n    }\n  }\n  function dataSectionOpen(code) {\n    effects.enter(\"componentContainerDataSection\");\n    return effects.attempt({\n      tokenize: tokenizeDataSection,\n      partial: true\n    }, dataSectionClose, dataChunkStart)(code);\n  }\n  function dataChunkStart(code) {\n    if (code === null) {\n      effects.exit(\"componentContainerDataSection\");\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    const token = effects.enter(\"chunkDocument\", {\n      contentType: \"document\",\n      previous\n    });\n    if (previous) {\n      previous.next = token;\n    }\n    previous = token;\n    return dataContentContinue(code);\n  }\n  function dataContentContinue(code) {\n    if (code === null) {\n      effects.exit(\"chunkDocument\");\n      effects.exit(\"componentContainerDataSection\");\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      effects.exit(\"chunkDocument\");\n      return effects.attempt({\n        tokenize: tokenizeDataSection,\n        partial: true\n      }, dataSectionClose, dataChunkStart);\n    }\n    effects.consume(code);\n    return dataContentContinue;\n  }\n  function dataSectionClose(code) {\n    effects.exit(\"componentContainerDataSection\");\n    return factorySpace(effects, next, \"whitespace\")(code);\n  }\n}\n\nconst label = { tokenize: tokenizeLabel, partial: true };\nconst attributes = { tokenize: tokenizeAttributes, partial: true };\nfunction tokenize$2(effects, ok, nok) {\n  const self = this;\n  const initialPrefix = linePrefixSize(this.events);\n  let sizeOpen = 0;\n  let previous;\n  const childContainersSequenceSize = [];\n  let containerFirstLine = true;\n  let possibleIndentedComponent = false;\n  let containerIndentSize = 0;\n  let visitingCodeFenced = false;\n  const section = useTokenState(\"componentContainerSection\");\n  return start;\n  function start(code) {\n    if (code !== Codes.colon) {\n      throw new Error(\"expected `:`\");\n    }\n    effects.enter(\"componentContainer\");\n    effects.enter(\"componentContainerFence\");\n    effects.enter(\"componentContainerSequence\");\n    return sequenceOpen(code);\n  }\n  function tokenizeSectionClosing(effects2, ok2, nok2) {\n    let size = 0;\n    let sectionIndentSize = 0;\n    let revertSectionState;\n    return closingPrefixAfter;\n    function closingPrefixAfter(code) {\n      sectionIndentSize = linePrefixSize(self.events);\n      revertSectionState = section.exit(effects2);\n      effects2.enter(\"componentContainerSectionSequence\");\n      return closingSectionSequence(code);\n    }\n    function closingSectionSequence(code) {\n      if (code === slotSeparatorCode) {\n        effects2.consume(code);\n        size++;\n        return closingSectionSequence;\n      }\n      if (size !== slotSeparatorLength) {\n        revertSectionState();\n        return nok2(code);\n      }\n      if (sectionIndentSize !== initialPrefix) {\n        revertSectionState();\n        return nok2(code);\n      }\n      if (!asciiAlpha(code)) {\n        revertSectionState();\n        return nok2(code);\n      }\n      effects2.exit(\"componentContainerSectionSequence\");\n      return factorySpace(effects2, ok2, \"whitespace\")(code);\n    }\n  }\n  function sectionOpen(code) {\n    section.enter(effects);\n    if (markdownLineEnding(code)) {\n      return factorySpace(effects, lineStart, \"whitespace\")(code);\n    }\n    effects.enter(\"componentContainerSectionTitle\");\n    return sectionTitle(code);\n  }\n  function sectionTitle(code) {\n    if (code === Codes.openingCurlyBracket) {\n      return effects.check(\n        attributes,\n        (code2) => {\n          effects.exit(\"componentContainerSectionTitle\");\n          return effects.attempt(attributes, factorySpace(effects, lineStart, \"linePrefix\", 4), nok)(code2);\n        },\n        (code2) => {\n          effects.consume(code2);\n          return sectionTitle;\n        }\n      )(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.exit(\"componentContainerSectionTitle\");\n      return factorySpace(effects, lineStart, \"linePrefix\", 4)(code);\n    }\n    effects.consume(code);\n    return sectionTitle;\n  }\n  function sequenceOpen(code) {\n    if (code === Codes.colon) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < ContainerSequenceSize) {\n      return nok(code);\n    }\n    effects.exit(\"componentContainerSequence\");\n    return createName.call(self, effects, afterName, nok, \"componentContainerName\")(code);\n  }\n  function afterName(code) {\n    return code === Codes.openingSquareBracket ? effects.attempt(label, afterLabel, afterLabel)(code) : afterLabel(code);\n  }\n  function afterLabel(code) {\n    return code === Codes.openingCurlyBracket ? effects.attempt(attributes, afterAttributes, afterAttributes)(code) : afterAttributes(code);\n  }\n  function afterAttributes(code) {\n    return factorySpace(effects, openAfter, \"whitespace\")(code);\n  }\n  function openAfter(code) {\n    effects.exit(\"componentContainerFence\");\n    if (code === null) {\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return self.interrupt ? ok : contentStart;\n    }\n    return nok(code);\n  }\n  function contentStart(code) {\n    if (code === null) {\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    if (containerFirstLine && (code === Codes.dash || markdownSpace(code))) {\n      containerFirstLine = false;\n      return tokenizeFrontMatter(effects, ok, nok, contentStart, initialPrefix)(code);\n    }\n    effects.enter(\"componentContainerContent\");\n    return lineStart(code);\n  }\n  function lineStartAfterPrefix(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (code === Codes.backTick) {\n      return effects.check(\n        tokenizeCodeFence,\n        (code2) => {\n          visitingCodeFenced = !visitingCodeFenced;\n          return chunkStart(code2);\n        },\n        chunkStart\n      )(code);\n    }\n    if (visitingCodeFenced) {\n      return chunkStart(code);\n    }\n    if (!childContainersSequenceSize.length && (code === slotSeparatorCode || code === Codes.space)) {\n      return effects.attempt(\n        { tokenize: tokenizeSectionClosing, partial: true },\n        sectionOpen,\n        chunkStart\n      )(code);\n    }\n    if (code === Codes.colon) {\n      return effects.attempt(\n        { tokenize: tokenizeClosingFence, partial: true },\n        after,\n        chunkStart\n      )(code);\n    }\n    return chunkStart(code);\n  }\n  function dentendIndentedCommponent(code) {\n    if (containerIndentSize) {\n      return factorySpace(effects, lineStartAfterPrefix, \"linePrefix\", containerIndentSize + 1)(code);\n    }\n    return lineStartAfterPrefix(code);\n  }\n  function attemptIntentedCommponent(code) {\n    if (containerIndentSize) {\n      return factorySpace(effects, lineStartAfterPrefix, \"linePrefix\", containerIndentSize + 1)(code);\n    }\n    return effects.check(\n      { tokenize: tokenizeContainerIndent, partial: true },\n      dentendIndentedCommponent,\n      lineStartAfterPrefix\n    )(code);\n  }\n  function lineStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n    let nextState = dentendIndentedCommponent;\n    if (possibleIndentedComponent) {\n      nextState = attemptIntentedCommponent;\n    }\n    possibleIndentedComponent = markdownLineEnding(code);\n    return initialPrefix > 0 ? factorySpace(effects, nextState, \"linePrefix\", initialPrefix + 1)(code) : nextState(code);\n  }\n  function chunkStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n    section.enterOnce(effects);\n    const token = effects.enter(\"chunkDocument\", {\n      contentType: \"document\",\n      previous\n    });\n    if (previous) {\n      previous.next = token;\n    }\n    previous = token;\n    return contentContinue(code);\n  }\n  function contentContinue(code) {\n    if (code === null) {\n      effects.exit(\"chunkDocument\");\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      effects.exit(\"chunkDocument\");\n      return lineStart;\n    }\n    effects.consume(code);\n    return contentContinue;\n  }\n  function after(code) {\n    section.exit(effects);\n    effects.exit(\"componentContainerContent\");\n    effects.exit(\"componentContainer\");\n    return ok(code);\n  }\n  function tokenizeClosingFence(effects2, ok2, nok2) {\n    let size = 0;\n    return factorySpace(effects2, closingPrefixAfter, \"linePrefix\", 4);\n    function closingPrefixAfter(code) {\n      effects2.enter(\"componentContainerFence\");\n      effects2.enter(\"componentContainerSequence\");\n      return closingSequence(code);\n    }\n    function closingSequence(code) {\n      if (code === Codes.colon) {\n        effects2.consume(code);\n        size++;\n        return closingSequence;\n      }\n      if (childContainersSequenceSize.length) {\n        if (size === childContainersSequenceSize[childContainersSequenceSize.length - 1]) {\n          childContainersSequenceSize.pop();\n        }\n        return nok2(code);\n      }\n      if (size !== sizeOpen) {\n        return nok2(code);\n      }\n      effects2.exit(\"componentContainerSequence\");\n      return factorySpace(effects2, closingSequenceEnd, \"whitespace\")(code);\n    }\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects2.exit(\"componentContainerFence\");\n        return ok2(code);\n      }\n      childContainersSequenceSize.push(size);\n      return nok2(code);\n    }\n  }\n  function tokenizeContainerIndent(effects2, ok2, nok2) {\n    let size = 0;\n    function start2(code) {\n      if (code !== Codes.space) {\n        return nok2(code);\n      }\n      return factory(code);\n    }\n    function factory(code) {\n      effects2.enter(\"linePrefix\");\n      if (code === Codes.space) {\n        effects2.consume(code);\n        size += 1;\n        return factory;\n      }\n      return containerCheck(code);\n    }\n    return start2;\n    function containerCheck(code) {\n      if (code === Codes.colon && size > 0) {\n        containerIndentSize = size;\n        return ok2(code);\n      }\n      if (markdownLineEnding(code)) {\n        possibleIndentedComponent = false;\n        containerIndentSize = 0;\n        return ok2(code);\n      }\n      return nok2(code);\n    }\n  }\n}\nfunction tokenizeLabel(effects, ok, nok) {\n  return createLabel(\n    effects,\n    ok,\n    nok,\n    \"componentContainerLabel\",\n    \"componentContainerLabelMarker\",\n    \"componentContainerLabelString\",\n    true\n  );\n}\nfunction tokenizeAttributes(effects, ok, nok) {\n  return createAttributes(\n    effects,\n    ok,\n    nok,\n    \"componentContainerAttributes\",\n    \"componentContainerAttributesMarker\",\n    \"componentContainerAttribute\",\n    \"componentContainerAttributeId\",\n    \"componentContainerAttributeClass\",\n    \"componentContainerAttributeName\",\n    \"componentContainerAttributeInitializerMarker\",\n    \"componentContainerAttributeValueLiteral\",\n    \"componentContainerAttributeValue\",\n    \"componentContainerAttributeValueMarker\",\n    \"componentContainerAttributeValueData\",\n    true\n  );\n}\nconst tokenizeContainer = {\n  tokenize: tokenize$2,\n  concrete: true\n};\n\nfunction tokenize$1(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, lineStart, \"linePrefix\");\n  function lineStart(code) {\n    if (prefixSize(self.events, \"linePrefix\") < 4) {\n      return nok(code);\n    }\n    switch (code) {\n      case Codes.backTick:\n        return codeFenced.tokenize.call(self, effects, ok, nok)(code);\n      case Codes.colon:\n        return tokenizeContainer.tokenize.call(self, effects, ok, nok)(code);\n      default:\n        return nok(code);\n    }\n  }\n}\nconst tokenizeContainerIndented = {\n  tokenize: tokenize$1\n};\n\nfunction tokenize(effects, ok, nok) {\n  const self = this;\n  const tokenizeSugerSyntax = tokenizeInline.tokenize.call(\n    self,\n    effects,\n    factorySpace(effects, exit, \"linePrefix\"),\n    nok\n  );\n  return factorySpace(effects, lineStart, \"linePrefix\");\n  function lineStart(code) {\n    if (code === Codes.colon) {\n      return tokenizeSugerSyntax(code);\n    }\n    return nok(code);\n  }\n  function exit(code) {\n    if (markdownLineEnding(code) || code === Codes.EOF) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\nconst tokenizeContainerSuger = {\n  tokenize\n};\n\nfunction micromarkComponentsExtension() {\n  return {\n    text: {\n      [Codes.colon]: tokenizeInline,\n      [Codes.openingSquareBracket]: [tokenizeSpan],\n      [Codes.openingCurlyBracket]: [tokenizeBinding, tokenizeAttribute]\n    },\n    flow: {\n      [Codes.colon]: [tokenizeContainer, tokenizeContainerSuger]\n    },\n    flowInitial: {\n      \"-2\": tokenizeContainerIndented,\n      \"-1\": tokenizeContainerIndented,\n      [Codes.space]: tokenizeContainerIndented\n    }\n  };\n}\n\nconst toFrontMatter = (yamlString) => `---\n${yamlString}\n---`;\nconst remarkMDC = (function remarkMDC(opts = {}) {\n  const data = this.data();\n  if (opts.autoUnwrap === void 0 && opts.experimental?.autoUnwrap) {\n    opts.autoUnwrap = opts.experimental.autoUnwrap ? { safeTypes: [] } : false;\n  }\n  opts.attributes ||= {};\n  opts.attributes.maxLength = opts.attributes.maxLength ?? opts.maxAttributesLength ?? 80;\n  opts.attributes.yamlCodeBlock = opts.attributes.yamlCodeBlock ?? opts.yamlCodeBlockProps ?? opts.experimental?.componentCodeBlockYamlProps ?? false;\n  add(\"micromarkExtensions\", micromarkComponentsExtension());\n  add(\"fromMarkdownExtensions\", fromMarkdown(opts));\n  add(\"toMarkdownExtensions\", toMarkdown(opts));\n  function add(field, value) {\n    if (!data[field]) {\n      data[field] = [];\n    }\n    data[field].push(value);\n  }\n  if (opts?.components?.length) {\n    return async (tree, { data: data2 }) => {\n      const jobs = [];\n      visit(tree, [\"textComponent\", \"leafComponent\", \"containerComponent\"], (node) => {\n        bindNode(node, opts[\"frontmatter\"]);\n        const { instance: handler, options } = opts.components.find((c) => c.name === node.name) || {};\n        if (handler) {\n          jobs.push(handler(options)(node, data2));\n        }\n      });\n      await Promise.all(jobs);\n      return tree;\n    };\n  }\n  return (tree) => {\n    visit(tree, [\"textComponent\", \"leafComponent\", \"containerComponent\"], (node) => {\n      bindNode(node, opts[\"frontmatter\"]);\n    });\n  };\n});\nfunction bindNode(node, options) {\n  const nodeData = node.data || (node.data = {});\n  node.fmAttributes = getNodeData(node, options);\n  nodeData.hName = kebabCase(node.name);\n  nodeData.hProperties = bindData(\n    {\n      ...node.attributes,\n      // Parse data slots and retrieve data\n      ...node.fmAttributes\n    }\n  );\n}\nfunction getNodeData(node, options) {\n  if (node.rawData) {\n    const yaml = node.rawData.replace(/\\s-+$/, \"\");\n    const { data } = parseFrontMatter(toFrontMatter(yaml), options);\n    return data;\n  }\n  return {};\n}\nfunction bindData(data) {\n  const entries = Object.entries(data).map(([key, value]) => {\n    if (key.startsWith(\":\")) {\n      return [key, value];\n    }\n    if (typeof value === \"string\") {\n      return [key, value];\n    }\n    return [`:${key}`, JSON.stringify(value)];\n  });\n  return Object.fromEntries(entries);\n}\n\nexport { convertHtmlEntitiesToChars, remarkMDC as default, micromarkComponentsExtension as micromarkExtension, parseFrontMatter, stringifyFrontMatter };\n", "function isBuffer (obj) {\n  return obj &&\n    obj.constructor &&\n    (typeof obj.constructor.isBuffer === 'function') &&\n    obj.constructor.isBuffer(obj)\n}\n\nfunction keyIdentity (key) {\n  return key\n}\n\nexport function flatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const maxDepth = opts.maxDepth\n  const transformKey = opts.transformKey || keyIdentity\n  const output = {}\n\n  function step (object, prev, currentDepth) {\n    currentDepth = currentDepth || 1\n    Object.keys(object).forEach(function (key) {\n      const value = object[key]\n      const isarray = opts.safe && Array.isArray(value)\n      const type = Object.prototype.toString.call(value)\n      const isbuffer = isBuffer(value)\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      const newKey = prev\n        ? prev + delimiter + transformKey(key)\n        : transformKey(key)\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&\n        (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1)\n      }\n\n      output[newKey] = value\n    })\n  }\n\n  step(target)\n\n  return output\n}\n\nexport function unflatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const transformKey = opts.transformKey || keyIdentity\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey (key) {\n    const parsedKey = Number(key)\n\n    return (\n      isNaN(parsedKey) ||\n      key.indexOf('.') !== -1 ||\n      opts.object\n    )\n      ? key\n      : parsedKey\n  }\n\n  function addKeys (keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key]\n\n      return result\n    }, recipient)\n  }\n\n  function isEmpty (val) {\n    const type = Object.prototype.toString.call(val)\n    const isArray = type === '[object Array]'\n    const isObject = type === '[object Object]'\n\n    if (!val) {\n      return true\n    } else if (isArray) {\n      return !val.length\n    } else if (isObject) {\n      return !Object.keys(val).length\n    }\n  }\n\n  target = Object.keys(target).reduce(function (result, key) {\n    const type = Object.prototype.toString.call(target[key])\n    const isObject = (type === '[object Object]' || type === '[object Array]')\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key]\n      return result\n    } else {\n      return addKeys(\n        key,\n        result,\n        flatten(target[key], opts)\n      )\n    }\n  }, {})\n\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result\n\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return\n      }\n\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = (\n          typeof key2 === 'number' &&\n          !opts.object\n            ? []\n            : {}\n        )\n      }\n\n      recipient = recipient[key1]\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts)\n  })\n\n  return result\n}\n", "/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n", "/**\n * List of legacy HTML named character references that dont need a trailing semicolon.\n *\n * @type {Array<string>}\n */\nexport const characterEntitiesLegacy = [\n  'AElig',\n  'AMP',\n  'Aacute',\n  'Acirc',\n  'Agrave',\n  'Aring',\n  'Atilde',\n  'Auml',\n  'COPY',\n  'Ccedil',\n  'ETH',\n  'Eacute',\n  'Ecirc',\n  'Egrave',\n  'Euml',\n  'GT',\n  'Iacute',\n  'Icirc',\n  'Igrave',\n  'Iuml',\n  'LT',\n  'Ntilde',\n  'Oacute',\n  'Ocirc',\n  'Ograve',\n  'Oslash',\n  'Otilde',\n  'Ouml',\n  'QUOT',\n  'REG',\n  'THORN',\n  'Uacute',\n  'Ucirc',\n  'Ugrave',\n  'Uuml',\n  'Yacute',\n  'aacute',\n  'acirc',\n  'acute',\n  'aelig',\n  'agrave',\n  'amp',\n  'aring',\n  'atilde',\n  'auml',\n  'brvbar',\n  'ccedil',\n  'cedil',\n  'cent',\n  'copy',\n  'curren',\n  'deg',\n  'divide',\n  'eacute',\n  'ecirc',\n  'egrave',\n  'eth',\n  'euml',\n  'frac12',\n  'frac14',\n  'frac34',\n  'gt',\n  'iacute',\n  'icirc',\n  'iexcl',\n  'igrave',\n  'iquest',\n  'iuml',\n  'laquo',\n  'lt',\n  'macr',\n  'micro',\n  'middot',\n  'nbsp',\n  'not',\n  'ntilde',\n  'oacute',\n  'ocirc',\n  'ograve',\n  'ordf',\n  'ordm',\n  'oslash',\n  'otilde',\n  'ouml',\n  'para',\n  'plusmn',\n  'pound',\n  'quot',\n  'raquo',\n  'reg',\n  'sect',\n  'shy',\n  'sup1',\n  'sup2',\n  'sup3',\n  'szlig',\n  'thorn',\n  'times',\n  'uacute',\n  'ucirc',\n  'ugrave',\n  'uml',\n  'uuml',\n  'yacute',\n  'yen',\n  'yuml'\n]\n", "/**\n * Map of named character references from HTML 4.\n *\n * @type {Record<string, string>}\n */\nexport const characterEntitiesHtml4 = {\n  nbsp: '',\n  iexcl: '',\n  cent: '',\n  pound: '',\n  curren: '',\n  yen: '',\n  brvbar: '',\n  sect: '',\n  uml: '',\n  copy: '',\n  ordf: '',\n  laquo: '',\n  not: '',\n  shy: '',\n  reg: '',\n  macr: '',\n  deg: '',\n  plusmn: '',\n  sup2: '',\n  sup3: '',\n  acute: '',\n  micro: '',\n  para: '',\n  middot: '',\n  cedil: '',\n  sup1: '',\n  ordm: '',\n  raquo: '',\n  frac14: '',\n  frac12: '',\n  frac34: '',\n  iquest: '',\n  Agrave: '',\n  Aacute: '',\n  Acirc: '',\n  Atilde: '',\n  Auml: '',\n  Aring: '',\n  AElig: '',\n  Ccedil: '',\n  Egrave: '',\n  Eacute: '',\n  Ecirc: '',\n  Euml: '',\n  Igrave: '',\n  Iacute: '',\n  Icirc: '',\n  Iuml: '',\n  ETH: '',\n  Ntilde: '',\n  Ograve: '',\n  Oacute: '',\n  Ocirc: '',\n  Otilde: '',\n  Ouml: '',\n  times: '',\n  Oslash: '',\n  Ugrave: '',\n  Uacute: '',\n  Ucirc: '',\n  Uuml: '',\n  Yacute: '',\n  THORN: '',\n  szlig: '',\n  agrave: '',\n  aacute: '',\n  acirc: '',\n  atilde: '',\n  auml: '',\n  aring: '',\n  aelig: '',\n  ccedil: '',\n  egrave: '',\n  eacute: '',\n  ecirc: '',\n  euml: '',\n  igrave: '',\n  iacute: '',\n  icirc: '',\n  iuml: '',\n  eth: '',\n  ntilde: '',\n  ograve: '',\n  oacute: '',\n  ocirc: '',\n  otilde: '',\n  ouml: '',\n  divide: '',\n  oslash: '',\n  ugrave: '',\n  uacute: '',\n  ucirc: '',\n  uuml: '',\n  yacute: '',\n  thorn: '',\n  yuml: '',\n  fnof: '',\n  Alpha: '',\n  Beta: '',\n  Gamma: '',\n  Delta: '',\n  Epsilon: '',\n  Zeta: '',\n  Eta: '',\n  Theta: '',\n  Iota: '',\n  Kappa: '',\n  Lambda: '',\n  Mu: '',\n  Nu: '',\n  Xi: '',\n  Omicron: '',\n  Pi: '',\n  Rho: '',\n  Sigma: '',\n  Tau: '',\n  Upsilon: '',\n  Phi: '',\n  Chi: '',\n  Psi: '',\n  Omega: '',\n  alpha: '',\n  beta: '',\n  gamma: '',\n  delta: '',\n  epsilon: '',\n  zeta: '',\n  eta: '',\n  theta: '',\n  iota: '',\n  kappa: '',\n  lambda: '',\n  mu: '',\n  nu: '',\n  xi: '',\n  omicron: '',\n  pi: '',\n  rho: '',\n  sigmaf: '',\n  sigma: '',\n  tau: '',\n  upsilon: '',\n  phi: '',\n  chi: '',\n  psi: '',\n  omega: '',\n  thetasym: '',\n  upsih: '',\n  piv: '',\n  bull: '',\n  hellip: '',\n  prime: '',\n  Prime: '',\n  oline: '',\n  frasl: '',\n  weierp: '',\n  image: '',\n  real: '',\n  trade: '',\n  alefsym: '',\n  larr: '',\n  uarr: '',\n  rarr: '',\n  darr: '',\n  harr: '',\n  crarr: '',\n  lArr: '',\n  uArr: '',\n  rArr: '',\n  dArr: '',\n  hArr: '',\n  forall: '',\n  part: '',\n  exist: '',\n  empty: '',\n  nabla: '',\n  isin: '',\n  notin: '',\n  ni: '',\n  prod: '',\n  sum: '',\n  minus: '',\n  lowast: '',\n  radic: '',\n  prop: '',\n  infin: '',\n  ang: '',\n  and: '',\n  or: '',\n  cap: '',\n  cup: '',\n  int: '',\n  there4: '',\n  sim: '',\n  cong: '',\n  asymp: '',\n  ne: '',\n  equiv: '',\n  le: '',\n  ge: '',\n  sub: '',\n  sup: '',\n  nsub: '',\n  sube: '',\n  supe: '',\n  oplus: '',\n  otimes: '',\n  perp: '',\n  sdot: '',\n  lceil: '',\n  rceil: '',\n  lfloor: '',\n  rfloor: '',\n  lang: '',\n  rang: '',\n  loz: '',\n  spades: '',\n  clubs: '',\n  hearts: '',\n  diams: '',\n  quot: '\"',\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  OElig: '',\n  oelig: '',\n  Scaron: '',\n  scaron: '',\n  Yuml: '',\n  circ: '',\n  tilde: '',\n  ensp: '',\n  emsp: '',\n  thinsp: '',\n  zwnj: '',\n  zwj: '',\n  lrm: '',\n  rlm: '',\n  ndash: '',\n  mdash: '',\n  lsquo: '',\n  rsquo: '',\n  sbquo: '',\n  ldquo: '',\n  rdquo: '',\n  bdquo: '',\n  dagger: '',\n  Dagger: '',\n  permil: '',\n  lsaquo: '',\n  rsaquo: '',\n  euro: ''\n}\n", "import {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterEntitiesHtml4} from 'character-entities-html4'\nimport {dangerous} from '../constant/dangerous.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * `characterEntitiesHtml4` but inverted.\n *\n * @type {Record<string, string>}\n */\nconst characters = {}\n\n/** @type {string} */\nlet key\n\nfor (key in characterEntitiesHtml4) {\n  if (own.call(characterEntitiesHtml4, key)) {\n    characters[characterEntitiesHtml4[key]] = key\n  }\n}\n\nconst notAlphanumericRegex = /[^\\dA-Za-z]/\n\n/**\n * Configurable ways to encode characters as named references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @param {boolean|undefined} attribute\n * @returns {string}\n */\nexport function toNamed(code, next, omit, attribute) {\n  const character = String.fromCharCode(code)\n\n  if (own.call(characters, character)) {\n    const name = characters[character]\n    const value = '&' + name\n\n    if (\n      omit &&\n      characterEntitiesLegacy.includes(name) &&\n      !dangerous.includes(name) &&\n      (!attribute ||\n        (next &&\n          next !== 61 /* `=` */ &&\n          notAlphanumericRegex.test(String.fromCharCode(next))))\n    ) {\n      return value\n    }\n\n    return value + ';'\n  }\n\n  return ''\n}\n", "/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n", "/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n", "/**\n * Map of invalid numeric character references to their replacements, according to HTML.\n *\n * @type {Record<number, string>}\n */\nexport const characterReferenceInvalid = {\n  0: '',\n  128: '',\n  130: '',\n  131: '',\n  132: '',\n  133: '',\n  134: '',\n  135: '',\n  136: '',\n  137: '',\n  138: '',\n  139: '',\n  140: '',\n  142: '',\n  145: '',\n  146: '',\n  147: '',\n  148: '',\n  149: '',\n  150: '',\n  151: '',\n  152: '',\n  153: '',\n  154: '',\n  155: '',\n  156: '',\n  158: '',\n  159: ''\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is decimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is a decimal\n */\nexport function isDecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is hexadecimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is hexadecimal\n */\nexport function isHexadecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 /* a */ && code <= 102) /* z */ ||\n    (code >= 65 /* A */ && code <= 70) /* Z */ ||\n    (code >= 48 /* A */ && code <= 57) /* Z */\n  )\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is alphabetical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphabetical.\n */\nexport function isAlphabetical(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n", "import {isAlphabetical} from 'is-alphabetical'\nimport {isDecimal} from 'is-decimal'\n\n/**\n * Check if the given character code, or the character code at the first\n * character, is alphanumerical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphanumerical.\n */\nexport function isAlphanumerical(character) {\n  return isAlphabetical(character) || isDecimal(character)\n}\n", "/**\n * @import {Point} from 'unist'\n * @import {Options} from '../index.js'\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {Readonly<Options> | null | undefined} [options]\n */\nexport function parseEntities(value, options) {\n  const settings = options || {}\n  const additional =\n    typeof settings.additional === 'string'\n      ? settings.additional.charCodeAt(0)\n      : settings.additional\n  /** @type {Array<string>} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point | undefined} */\n  let point\n  /** @type {Array<number>|undefined} */\n  let indent\n\n  if (settings.position) {\n    if ('start' in settings.position || 'indent' in settings.position) {\n      // @ts-expect-error: points dont have indent.\n      indent = settings.position.indent\n      // @ts-expect-error: points dont have indent.\n      point = settings.position.start\n    } else {\n      point = settings.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += String.fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n            ? isDecimal\n            : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += String.fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && settings.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless its numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If theres something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (settings.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = String.fromCharCode(65533 /* `` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += String.fromCharCode(\n              (referenceCode >>> (10 & 0x3ff)) | 0xd800\n            )\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + String.fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (settings.reference) {\n          settings.reference.call(\n            settings.referenceContext || undefined,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += String.fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (settings.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      settings.warning.call(\n        settings.warningContext || undefined,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (settings.text) {\n        settings.text.call(settings.textContext || undefined, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n"],
  "mappings": "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",
  "names": ["key", "target", "result", "key2", "previous", "following", "characters", "key", "handle", "attributes", "label", "label2", "attributes2", "shortcut", "previous", "remarkMDC"]
}
