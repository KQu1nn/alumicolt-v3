import {
  codeFenced,
  decodeNamedCharacterReference,
  factorySpace,
  factoryWhitespace,
  handle
} from "./chunk-TOEF6JMF.js";
import "./chunk-F3FP73SH.js";
import {
  asciiAlpha,
  asciiAlphanumeric,
  markdownLineEnding,
  markdownLineEndingOrSpace,
  markdownSpace
} from "./chunk-CPOFQYXA.js";
import {
  visit
} from "./chunk-KEAJMK6I.js";
import "./chunk-RICDWKOF.js";
import "./chunk-7ISN2OOB.js";
import "./chunk-G3PMV62Z.js";

// node_modules/remark-mdc/dist/index.mjs
import { kebabCase } from "scule";
import { parseDocument, isMap, isSeq, isScalar, Document, stringify, YAMLMap, Pair, Scalar, YAMLSeq } from "yaml";

// node_modules/flat/index.js
function isBuffer(obj) {
  return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function keyIdentity(key2) {
  return key2;
}
function flatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const maxDepth = opts.maxDepth;
  const transformKey = opts.transformKey || keyIdentity;
  const output = {};
  function step(object, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object).forEach(function(key2) {
      const value = object[key2];
      const isarray = opts.safe && Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isbuffer = isBuffer(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? prev + delimiter + transformKey(key2) : transformKey(key2);
      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1);
      }
      output[newKey] = value;
    });
  }
  step(target);
  return output;
}
function unflatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const overwrite = opts.overwrite || false;
  const transformKey = opts.transformKey || keyIdentity;
  const result = {};
  const isbuffer = isBuffer(target);
  if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
    return target;
  }
  function getkey(key2) {
    const parsedKey = Number(key2);
    return isNaN(parsedKey) || key2.indexOf(".") !== -1 || opts.object ? key2 : parsedKey;
  }
  function addKeys(keyPrefix, recipient, target2) {
    return Object.keys(target2).reduce(function(result2, key2) {
      result2[keyPrefix + delimiter + key2] = target2[key2];
      return result2;
    }, recipient);
  }
  function isEmpty(val) {
    const type = Object.prototype.toString.call(val);
    const isArray = type === "[object Array]";
    const isObject = type === "[object Object]";
    if (!val) {
      return true;
    } else if (isArray) {
      return !val.length;
    } else if (isObject) {
      return !Object.keys(val).length;
    }
  }
  target = Object.keys(target).reduce(function(result2, key2) {
    const type = Object.prototype.toString.call(target[key2]);
    const isObject = type === "[object Object]" || type === "[object Array]";
    if (!isObject || isEmpty(target[key2])) {
      result2[key2] = target[key2];
      return result2;
    } else {
      return addKeys(
        key2,
        result2,
        flatten(target[key2], opts)
      );
    }
  }, {});
  Object.keys(target).forEach(function(key2) {
    const split = key2.split(delimiter).map(transformKey);
    let key1 = getkey(split.shift());
    let key22 = getkey(split[0]);
    let recipient = result;
    while (key22 !== void 0) {
      if (key1 === "__proto__") {
        return;
      }
      const type = Object.prototype.toString.call(recipient[key1]);
      const isobject = type === "[object Object]" || type === "[object Array]";
      if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
        return;
      }
      if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
        recipient[key1] = typeof key22 === "number" && !opts.object ? [] : {};
      }
      recipient = recipient[key1];
      if (split.length > 0) {
        key1 = getkey(split.shift());
        key22 = getkey(split[0]);
      }
    }
    recipient[key1] = unflatten(target[key2], opts);
  });
  return result;
}

// node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index, all) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all.charCodeAt(index + 2),
      options
    );
  }
  function basic(character, index, all) {
    return options.format(
      character.charCodeAt(0),
      all.charCodeAt(index + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index = -1;
  while (++index < subset.length) {
    groups.push(subset[index].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};

// node_modules/stringify-entities/lib/util/to-named.js
var own = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}

// node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code) {
  return "&#x" + code.toString(16).toUpperCase() + ";";
}

// node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value, options) {
  return core(value, Object.assign({ format: formatBasic }, options));
}

// node_modules/character-reference-invalid/index.js
var characterReferenceInvalid = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};

// node_modules/is-decimal/index.js
function isDecimal(character) {
  const code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 48 && code <= 57;
}

// node_modules/is-hexadecimal/index.js
function isHexadecimal(character) {
  const code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
}

// node_modules/is-alphabetical/index.js
function isAlphabetical(character) {
  const code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}

// node_modules/is-alphanumerical/index.js
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}

// node_modules/parse-entities/lib/index.js
var messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value, options) {
  const settings = options || {};
  const additional = typeof settings.additional === "string" ? settings.additional.charCodeAt(0) : settings.additional;
  const result = [];
  let index = 0;
  let lines = -1;
  let queue = "";
  let point;
  let indent;
  if (settings.position) {
    if ("start" in settings.position || "indent" in settings.position) {
      indent = settings.position.indent;
      point = settings.position.start;
    } else {
      point = settings.position;
    }
  }
  let line = (point ? point.line : 0) || 1;
  let column = (point ? point.column : 0) || 1;
  let previous2 = now();
  let character;
  index--;
  while (++index <= value.length) {
    if (character === 10) {
      column = (indent ? indent[lines] : 0) || 1;
    }
    character = value.charCodeAt(index);
    if (character === 38) {
      const following = value.charCodeAt(index + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += String.fromCharCode(character);
        column++;
        continue;
      }
      const start = index + 1;
      let begin = start;
      let end = start;
      let type;
      if (following === 35) {
        end = ++begin;
        const following2 = value.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type = "hexadecimal";
          end = ++begin;
        } else {
          type = "decimal";
        }
      } else {
        type = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference = "";
      let characters2 = "";
      const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
      end--;
      while (++end <= value.length) {
        const following2 = value.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters2 += String.fromCharCode(following2);
        if (type === "named" && characterEntitiesLegacy.includes(characters2)) {
          characterReferenceCharacters = characters2;
          characterReference = decodeNamedCharacterReference(characters2);
        }
      }
      let terminated = value.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type === "named" ? decodeNamedCharacterReference(characters2) : false;
        if (namedReference) {
          characterReferenceCharacters = characters2;
          characterReference = namedReference;
        }
      }
      let diff = 1 + end - start;
      let reference = "";
      if (!terminated && settings.nonTerminated === false) {
      } else if (!characters2) {
        if (type !== "named") {
          warning(4, diff);
        }
      } else if (type === "named") {
        if (terminated && !characterReference) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters2) {
            end = begin + characterReferenceCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (settings.attribute) {
              const following2 = value.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff);
                characterReference = "";
              } else if (isAlphanumerical(following2)) {
                characterReference = "";
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference = characterReference;
      } else {
        if (!terminated) {
          warning(2, diff);
        }
        let referenceCode = Number.parseInt(
          characters2,
          type === "hexadecimal" ? 16 : 10
        );
        if (prohibited(referenceCode)) {
          warning(7, diff);
          reference = String.fromCharCode(
            65533
            /* `�` */
          );
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += String.fromCharCode(
              referenceCode >>> (10 & 1023) | 55296
            );
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + String.fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous2 = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (settings.reference) {
          settings.reference.call(
            settings.referenceContext || void 0,
            reference,
            { start: previous2, end: next },
            value.slice(start - 1, end)
          );
        }
        previous2 = next;
      } else {
        characters2 = value.slice(start - 1, end);
        queue += characters2;
        column += characters2.length;
        index = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += String.fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index + ((point ? point.offset : 0) || 0)
    };
  }
  function warning(code, offset) {
    let position;
    if (settings.warning) {
      position = now();
      position.column += offset;
      position.offset += offset;
      settings.warning.call(
        settings.warningContext || void 0,
        messages[code],
        position,
        code
      );
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (settings.text) {
        settings.text.call(settings.textContext || void 0, queue, {
          start: previous2,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code) {
  return code >= 55296 && code <= 57343 || code > 1114111;
}
function disallowed(code) {
  return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
}

// node_modules/remark-mdc/dist/index.mjs
var FRONTMATTER_DELIMITER_DEFAULT = "---";
var FRONTMATTER_DELIMITER_CODEBLOCK_STYLE = "```yaml [props]";
var LF = "\n";
var CR = "\r";
function stringifyYAML(data, options) {
  if (!data || !Object.keys(data).length) return "";
  if (options?.preserveOrder && data.__order__) {
    const newDoc = new Document();
    newDoc.contents = buildFromOrdered(data.__order__);
    return String(newDoc).trim();
  }
  Reflect.deleteProperty(data, "__order__");
  data = unflatten(data || {}, {});
  return [
    options?.prefix || "",
    stringify(data, options).trim(),
    options?.suffix || ""
  ].join("\n").trim();
}
function stringifyFrontMatter(data, content = "", options) {
  const str = stringifyYAML(data, {
    prefix: FRONTMATTER_DELIMITER_DEFAULT,
    suffix: FRONTMATTER_DELIMITER_DEFAULT,
    ...options
  });
  return [str, "", content.trim()].join("\n").trim() + "\n";
}
function stringifyCodeBlockProps(data, content = "", options) {
  const str = stringifyYAML(data, {
    prefix: FRONTMATTER_DELIMITER_CODEBLOCK_STYLE,
    suffix: "```",
    ...options
  });
  return [str, content.trim()].join("\n").trim() + "\n";
}
function parseFrontMatter(content, options) {
  let data = {};
  if (content.startsWith(FRONTMATTER_DELIMITER_DEFAULT)) {
    const idx = content.indexOf(LF + FRONTMATTER_DELIMITER_DEFAULT);
    if (idx !== -1) {
      const hasCarriageReturn = content[idx - 1] === CR;
      const frontmatter = content.slice(4, idx - (hasCarriageReturn ? 1 : 0));
      if (frontmatter) {
        const document = parseDocument(frontmatter, options);
        data = document.toJSON();
        if (options?.preserveOrder) {
          data.__order__ = extractOrdered(document.contents);
        }
        content = content.slice(idx + 4 + (hasCarriageReturn ? 1 : 0));
      }
    }
  }
  return {
    content,
    // unflatten frontmatter data. convert `parent.child` keys into `parent: { child: ... }`
    data: unflatten(data || {}, {})
  };
}
function extractOrdered(valueNode) {
  if (isMap(valueNode)) {
    const map = [];
    for (const item of valueNode.items) {
      map.push([item.key.value, extractOrdered(item.value)]);
    }
    return { type: "map", value: map };
  }
  if (isSeq(valueNode)) {
    return { type: "seq", value: valueNode.items.map((item) => extractOrdered(item)) };
  }
  if (isScalar(valueNode)) {
    return { type: "scalar", value: valueNode.value };
  }
  return { type: "scalar", value: null };
}
function buildFromOrdered(orderedNode) {
  if (orderedNode.type === "map") {
    const map = new YAMLMap();
    for (const [key2, value] of orderedNode.value) {
      map.items.push(new Pair(new Scalar(key2), buildFromOrdered(value)));
    }
    return map;
  }
  if (orderedNode.type === "seq") {
    const seq = new YAMLSeq();
    for (const item of orderedNode.value) {
      seq.items.push(buildFromOrdered(item));
    }
    return seq;
  }
  return new Scalar(orderedNode.value);
}
function track(options_) {
  const options = options_ || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift(value) {
    lineShift += value;
  }
  function move(value = "") {
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}
function inlineContainerFlow(parent, context, safeOptions = {}) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const tracker = track(safeOptions);
  const results = [];
  let index = -1;
  indexStack.push(-1);
  while (++index < children.length) {
    const child = children[index];
    indexStack[indexStack.length - 1] = index;
    results.push(
      tracker.move(
        context.handle(child, parent, context, {
          before: "",
          after: "",
          ...tracker.current()
        })
      )
    );
  }
  indexStack.pop();
  return results.join("");
}
function containerFlow(parent, context, safeOptions = {}) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const tracker = track(safeOptions);
  const results = [];
  let index = -1;
  indexStack.push(-1);
  while (++index < children.length) {
    const child = children[index];
    indexStack[indexStack.length - 1] = index;
    results.push(
      tracker.move(
        context.handle(child, parent, context, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      context.bulletLastUsed = void 0;
    }
    if (index < children.length - 1) {
      results.push(tracker.move(between(child, children[index + 1])));
    }
  }
  indexStack.pop();
  return results.join("");
  function between(left, right) {
    let index2 = context.join.length;
    while (index2--) {
      const result = context.join[index2](left, right, parent, context);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
}
function containerPhrasing(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const results = [];
  let index = -1;
  let before = safeOptions.before;
  indexStack.push(-1);
  let tracker = track(safeOptions);
  while (++index < children.length) {
    const child = children[index];
    let after;
    indexStack[indexStack.length - 1] = index;
    if (index + 1 < children.length) {
      let handle2 = context.handle.handlers[children[index + 1].type];
      if (handle2 && handle2.peek) {
        handle2 = handle2.peek;
      }
      after = "";
      if (handle2) {
        after = handle2(
          children[index + 1],
          parent,
          context,
          {
            before: "",
            after: "",
            ...tracker.current()
          }
        ).charAt(0);
      }
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = track(safeOptions);
      tracker.move(results.join(""));
    }
    results.push(
      tracker.move(
        context.handle(child, parent, context, {
          ...tracker.current(),
          before,
          after
        })
      )
    );
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}
function checkQuote(context) {
  const marker = context.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}
var CONTAINER_NODE_TYPES = /* @__PURE__ */ new Set([
  "componentContainerSection",
  "containerComponent",
  "leafComponent"
]);
var NON_UNWRAPPABLE_TYPES = /* @__PURE__ */ new Set([
  "componentContainerSection",
  "componentContainerDataSection",
  "containerComponent",
  "leafComponent",
  "table",
  "pre",
  "code",
  "textComponent",
  "heading"
]);
function convertHtmlEntitiesToChars(text) {
  return text.replace(/&#x([0-9A-Fa-f]+);/g, (_, hexCode) => {
    return String.fromCodePoint(Number.parseInt(hexCode, 16));
  });
}
var shortcut = /^[^\t\n\r "'.<=>`}]+$/;
var baseFence = 2;
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}
var toMarkdown = (opts = {}) => {
  const applyAutomaticUnwrap = (node, _options) => {
    if (!CONTAINER_NODE_TYPES.has(node.type)) {
      return;
    }
    const isSafe = (type) => ["paragraph"].includes(type) || NON_UNWRAPPABLE_TYPES.has(type);
    const safeChildrens = node.children.filter((child) => !isSafe(child.type));
    if (safeChildrens.length === 0) {
      return;
    }
    node.children = [
      {
        type: "paragraph",
        children: safeChildrens
      },
      ...node.children.filter((child) => isSafe(child.type))
    ];
  };
  const frontmatter = (node) => {
    const entries = Object.entries(node.fmAttributes || {});
    if (entries.length === 0) {
      return "";
    }
    const attrs = entries.sort(([key1], [key2]) => key1.localeCompare(key2)).reduce((acc, [key2, value2]) => {
      if (key2?.startsWith(":") && isValidJSON(value2)) {
        try {
          value2 = JSON.parse(value2);
        } catch {
        }
        key2 = key2.slice(1);
      }
      acc[key2] = value2;
      return acc;
    }, {});
    return "\n" + (opts?.attributes?.yamlCodeBlock ? stringifyCodeBlockProps(attrs).trim() : stringifyFrontMatter(attrs).trim());
  };
  const processNode = (node) => {
    if (opts.autoUnwrap) {
      applyAutomaticUnwrap(node, typeof opts.autoUnwrap === "boolean" ? {} : opts.autoUnwrap);
    }
  };
  function componentContainerSection(node, _, context) {
    context.indexStack = context.stack;
    processNode(node);
    return `#${node.name}${attributes2(node, context)}
${content(node, context)}`.trim();
  }
  function textComponent(node, _, context) {
    let value;
    context.indexStack = context.stack;
    const exit = context.enter(node.type);
    if (node.name === "span") {
      value = `[${content(node, context)}]${attributes2(node, context)}`;
    } else if (node.name === "binding") {
      const attrs = node.attributes || {};
      value = attrs.defaultValue ? `{{ ${attrs.value} || '${attrs.defaultValue}' }}` : `{{ ${attrs.value} }}`;
    } else {
      value = ":" + (node.name || "") + label2(node, context) + attributes2(node, context);
    }
    exit();
    return value;
  }
  let nest = 0;
  function containerComponent(node, _, context) {
    context.indexStack = context.stack;
    const prefix = ":".repeat(baseFence + nest);
    nest += 1;
    const exit = context.enter(node.type);
    context.bulletLastUsed = void 0;
    let value = prefix + (node.name || "") + label2(node, context);
    const defaultSlotChildren = node.children.filter((child) => child.type !== "componentContainerSection");
    const slots = node.children.filter((child) => child.type === "componentContainerSection");
    node.children = [
      ...defaultSlotChildren,
      ...slots
    ];
    node.fmAttributes = node.fmAttributes || {};
    const attributesText = attributes2(node, context);
    const attributesEntries = Object.entries(node.attributes || {});
    if ((value + attributesText).length > (opts?.attributes?.maxLength || 80) || Object.keys(node.fmAttributes).length > 0 || attributesEntries.length > 3 || attributesEntries.some(([_2, value2]) => typeof value2 === "object") || attributesText.match(/(=['"][{[]|\n)/) || node.children?.some((child) => child.type === "componentContainerSection")) {
      Object.assign(node.fmAttributes, node.attributes);
      node.attributes = [];
    }
    processNode(node);
    value += attributes2(node, context);
    value += frontmatter(node);
    let subvalue;
    if (node.type === "containerComponent") {
      subvalue = content(node, context);
      if (subvalue) {
        value += "\n" + subvalue;
      }
      value += "\n" + prefix;
      if (nest > 1) {
        value = value.split("\n").map((line) => line.length > 0 ? "  " + line : line).join("\n");
      }
    }
    nest -= 1;
    exit();
    return value;
  }
  containerComponent.peek = function peekComponent() {
    return ":";
  };
  function label2(node, context) {
    let label22 = node;
    if (node.type === "containerComponent") {
      if (!inlineComponentLabel(node)) {
        return "";
      }
      label22 = node.children[0];
    }
    const exit = context.enter("label");
    const subexit = context.enter(node.type + "Label");
    const value = containerPhrasing(label22, context, { before: "[", after: "]" });
    subexit();
    exit();
    return value ? "[" + value + "]" : "";
  }
  const isValidJSON = (str) => {
    try {
      JSON.parse(str);
      return true;
    } catch {
      return false;
    }
  };
  function attributes2(node, context) {
    const quote = checkQuote(context);
    const subset = node.type === "textComponent" ? [quote] : [quote, "\n", "\r"];
    const attributes22 = node.attributes || {};
    const attrs = opts.attributes?.preserveOrder && attributes22.__order__ ? attributes22.__order__?.value : Object.entries(attributes22).sort(([key1], [key2]) => key1.localeCompare(key2));
    const values = [];
    let id;
    let classesFull = "";
    let classes = "";
    let index;
    for (const attr of attrs) {
      const key2 = attr[0];
      let value = attr[1];
      if (attr[1] != null) {
        value = String(attr[1]);
        if (key2 === "id") {
          id = shortcut.test(value) ? "#" + value : quoted("id", value);
        } else if (key2 === "class" || key2 === "className") {
          value = Array.isArray(attrs[key2]) ? attrs[key2].join(" ") : value;
          value = value.split(/[\t\n\r ]+/g).filter(Boolean);
          classesFull = [];
          classes = [];
          index = -1;
          while (++index < value.length) {
            (shortcut.test(value[index]) ? classes : classesFull).push(value[index]);
          }
          classesFull = classesFull.length ? quoted("class", classesFull.join(" ")) : "";
          classes = classes.length ? "." + classes.join(".") : "";
        } else if (key2.startsWith(":") && value === "true") {
          values.push(key2.slice(1));
        } else if (key2.startsWith(":") && isValidJSON(value)) {
          values.push(`${key2}='${value.replace(/([^/])'/g, "$1\\'")}'`);
        } else if (typeof attr[1] === "object") {
          values.push(quoted(key2, JSON.stringify(value)));
        } else {
          values.push(quoted(key2, value));
        }
      }
    }
    if (classesFull) {
      values.unshift(classesFull);
    }
    if (classes) {
      values.unshift(classes);
    }
    if (id) {
      values.unshift(id);
    }
    return values.length ? "{" + values.join(" ") + "}" : "";
    function quoted(key2, value) {
      return key2 + "=" + quote + stringifyEntitiesLight(value, { subset }) + quote;
    }
  }
  function content(node, context) {
    const content2 = inlineComponentLabel(node) ? Object.assign({}, node, { children: node.children.slice(1) }) : node;
    let result = node.type === "textComponent" ? inlineContainerFlow(content2, context) : containerFlow(content2, context);
    if (result.includes("&#x")) {
      result = convertHtmlEntitiesToChars(result);
    }
    return result;
  }
  function inlineComponentLabel(node) {
    return node.children && node.children[0] && node.children[0].data && node.children[0].data.componentLabel;
  }
  return {
    compilePattern,
    unsafe: [
      {
        character: "\r",
        inConstruct: ["leafComponentLabel", "containerComponentLabel"]
      },
      {
        character: "\n",
        inConstruct: ["leafComponentLabel", "containerComponentLabel"]
      },
      {
        before: "[^:]",
        character: ":",
        after: "[A-Za-z]",
        inConstruct: ["phrasing"]
      },
      { atBreak: true, character: ":", after: ":" }
    ],
    handlers: {
      containerComponent,
      textComponent,
      componentContainerSection,
      image: (node, _, state, info) => {
        return handle.image(node, _, state, info) + attributes2(node, state);
      },
      link: (node, _, state, info) => {
        const andPattern = state.unsafe.find((pattern) => pattern.character === "&");
        const defaultNotInConstruct = andPattern?.notInConstruct || [];
        if (andPattern) {
          andPattern.notInConstruct = "destinationRaw";
        }
        const result = handle.link(node, _, state, info) + attributes2(node, state);
        if (andPattern) {
          andPattern.notInConstruct = defaultNotInConstruct;
        }
        return result;
      },
      linkReference: (node, _, state, info) => {
        return handle.linkReference(node, _, state, info) + attributes2(node, state);
      },
      strong: (node, _, state, info) => {
        return handle.strong(node, _, state, info) + attributes2(node, state);
      },
      inlineCode: (node, _, state) => {
        state.compilePattern = state.compilePattern || compilePattern;
        return handle.inlineCode(node, _, state) + attributes2(node, state);
      },
      emphasis: (node, _, state, info) => {
        return handle.emphasis(node, _, state, info) + attributes2(node, state);
      }
    }
  };
};
var fromMarkdown = (opts = {}) => {
  const canContainEols = ["textComponent"];
  const applyYamlCodeBlockProps = (node) => {
    const firstSection = node.children[0];
    if (firstSection && firstSection.children?.length && firstSection.children[0]?.type === "code" && firstSection.children[0]?.lang === "yaml" && firstSection.children[0]?.meta === "[props]") {
      node.rawData = firstSection.children[0].value;
      node.mdc = node.mdc || {};
      node.mdc.codeBlockProps = true;
      firstSection.children.splice(0, 1);
    }
  };
  const applyAutomaticUnwrap = (node, _options) => {
    if (!CONTAINER_NODE_TYPES.has(node.type)) {
      return;
    }
    const nonSlotChildren = node.children.filter((child2) => child2.type !== "componentContainerSection");
    if (nonSlotChildren.length !== 1) {
      return;
    }
    const child = nonSlotChildren[0];
    if (child.type !== "paragraph") {
      return;
    }
    const childIndex = node.children.indexOf(child);
    node.children.splice(childIndex, 1, ...child?.children || []);
  };
  const processNode = (node) => {
    if (opts.attributes?.yamlCodeBlock) {
      applyYamlCodeBlockProps(node);
    }
    if (opts.autoUnwrap) {
      applyAutomaticUnwrap(node, typeof opts.autoUnwrap === "boolean" ? {} : opts.autoUnwrap);
    }
  };
  const enter = {
    componentContainer: enterContainer,
    componentContainerSection: enterContainerSection,
    componentContainerDataSection: enterContainerDataSection,
    componentContainerAttributes: enterAttributes,
    componentContainerLabel: enterContainerLabel,
    bindingContent: enterBindingContent,
    componentLeaf: enterLeaf,
    componentLeafAttributes: enterAttributes,
    componentText: enterText,
    textSpan: enterTextSpan,
    componentTextAttributes: enterAttributes
  };
  const exit = {
    bindingContent: exitBindingContent,
    componentContainerSectionTitle: exitContainerSectionTitle,
    listUnordered: conditionalExit,
    listOrdered: conditionalExit,
    listItem: conditionalExit,
    componentContainerSection: exitContainerSection,
    componentContainerDataSection: exitContainerDataSection,
    componentContainer: exitContainer,
    componentContainerAttributeClassValue: exitAttributeClassValue,
    componentContainerAttributeIdValue: exitAttributeIdValue,
    componentContainerAttributeName: exitAttributeName,
    componentContainerAttributeValue: exitAttributeValue,
    componentContainerAttributes: exitAttributes,
    componentContainerLabel: exitContainerLabel,
    componentContainerName,
    componentContainerAttributeInitializerMarker() {
      const attributes2 = this.data.componentAttributes;
      attributes2[attributes2.length - 1][1] = "";
    },
    componentLeaf: exitToken,
    componentLeafAttributeClassValue: exitAttributeClassValue,
    componentLeafAttributeIdValue: exitAttributeIdValue,
    componentLeafAttributeName: exitAttributeName,
    componentLeafAttributeValue: exitAttributeValue,
    componentLeafAttributes: exitAttributes,
    componentLeafName: exitName,
    componentText: exitToken,
    textSpan: exitToken,
    componentTextAttributeClassValue: exitAttributeClassValue,
    componentTextAttributeIdValue: exitAttributeIdValue,
    componentTextAttributeName: exitAttributeName,
    componentTextAttributeValue: exitAttributeValue,
    componentTextAttributes: exitAttributes,
    componentTextName: componentContainerName
  };
  function enterBindingContent(token) {
    const regex = /([^|]*)(?:\|\|\s*'(.*)')?/;
    const values = regex.exec(this.sliceSerialize(token));
    this.enter({
      type: "textComponent",
      name: "binding",
      attributes: {
        value: values?.[1]?.trim(),
        defaultValue: values?.[2]
      }
    }, token);
  }
  function exitBindingContent(token) {
    this.exit(token);
  }
  function enterContainer(token) {
    enterToken.call(this, "containerComponent", token);
  }
  function exitContainer(token) {
    const container = this.stack[this.stack.length - 1];
    if (container.children.length > 1) {
      const dataSection = container.children.find((child) => child.rawData);
      container.rawData = dataSection?.rawData;
    }
    processNode(container);
    container.children = container.children.flatMap((child) => {
      if (child.rawData) {
        return [];
      }
      if (child.name === "default" && Object.keys(child.attributes).length === 0 || !child.name) {
        if (child.mdc?.unwrapped) {
          container.mdc = container.mdc || {};
          container.mdc.unwrapped = child.mdc?.unwrapped;
        }
        return child.children;
      }
      child.data = {
        hName: "component-slot",
        hProperties: {
          ...child.attributes,
          [`v-slot:${child.name}`]: ""
        }
      };
      return child;
    });
    this.exit(token);
  }
  function enterContainerSection(token) {
    enterToken.call(this, "componentContainerSection", token);
  }
  function enterContainerDataSection(token) {
    enterToken.call(this, "componentContainerDataSection", token);
  }
  function exitContainerSection(token) {
    const section = this.stack[this.stack.length - 1];
    attemptClosingOpenListSection.call(this, section);
    processNode(section);
    this.exit(token);
  }
  function exitContainerDataSection(token) {
    let section = this.stack[this.stack.length - 1];
    section = attemptClosingOpenListSection.call(this, section);
    if (section.type === "componentContainerDataSection") {
      section.rawData = this.sliceSerialize(token);
      this.exit(token);
    }
  }
  function exitContainerSectionTitle(token) {
    this.stack[this.stack.length - 1].name = this.sliceSerialize(token)?.trim();
  }
  function enterLeaf(token) {
    enterToken.call(this, "leafComponent", token);
  }
  function enterTextSpan(token) {
    this.enter({ type: "textComponent", name: "span", attributes: {}, children: [] }, token);
  }
  function enterText(token) {
    enterToken.call(this, "textComponent", token);
  }
  function enterToken(type, token) {
    this.enter({ type, name: "", attributes: {}, children: [] }, token);
  }
  function componentContainerName(token) {
    this.stack[this.stack.length - 1].name = kebabCase(this.sliceSerialize(token));
  }
  function exitName(token) {
    this.stack[this.stack.length - 1].name = this.sliceSerialize(token);
  }
  function enterContainerLabel(token) {
    this.enter({ type: "paragraph", data: { componentLabel: true }, children: [] }, token);
  }
  function exitContainerLabel(token) {
    this.exit(token);
  }
  function enterAttributes() {
    this.data.componentAttributes = [];
    this.buffer();
  }
  function exitAttributeIdValue(token) {
    this.data.componentAttributes.push(["id", parseEntities(this.sliceSerialize(token))]);
  }
  function exitAttributeClassValue(token) {
    this.data.componentAttributes.push(["class", parseEntities(this.sliceSerialize(token))]);
  }
  function exitAttributeValue(token) {
    const attributes2 = this.data.componentAttributes;
    const lastAttribute = attributes2[attributes2.length - 1];
    lastAttribute[1] = (typeof lastAttribute[1] === "string" ? lastAttribute[1] : "") + parseEntities(this.sliceSerialize(token));
  }
  function exitAttributeName(token) {
    this.data.componentAttributes.push([this.sliceSerialize(token), true]);
  }
  function exitAttributes() {
    const attributes2 = this.data.componentAttributes;
    const cleaned = {};
    let index = -1;
    let attribute;
    while (++index < attributes2.length) {
      attribute = attributes2[index];
      const name = kebabCase(attribute[0]);
      if (name === "class" && cleaned.class) {
        cleaned.class += " " + attribute[1];
      } else {
        cleaned[name] = attribute[1];
      }
    }
    this.data.componentAttributes = attributes2;
    this.resume();
    let stackTop = this.stack[this.stack.length - 1];
    if (stackTop?.type !== "textComponent" || stackTop?.name === "span") {
      while (!stackTop?.position?.end && stackTop.children?.length > 0) {
        stackTop = stackTop.children[stackTop.children.length - 1];
      }
    }
    stackTop.attributes = opts.attributes?.preserveOrder ? { __order__: { type: "map", value: attributes2 }, ...cleaned } : cleaned;
  }
  function exitToken(token) {
    this.exit(token);
  }
  function conditionalExit(token) {
    const [section] = this.tokenStack[this.tokenStack.length - 1];
    if (section.type === token.type) {
      this.exit(token);
    }
  }
  function attemptClosingOpenListSection(section) {
    while (section.type === "listItem" || section.type === "list") {
      const [stackToken] = this.tokenStack[this.tokenStack.length - 1];
      this.exit(stackToken);
      section = this.stack[this.stack.length - 1];
    }
    return section;
  }
  return {
    canContainEols,
    enter,
    exit
  };
};
var ContainerSequenceSize = 2;
var SectionSequenceSize = 3;
var slotSeparatorCode = 35;
var slotSeparatorLength = 1;
var Codes = {
  /**
   * null
   */
  EOF: null,
  /**
   * ' '
   */
  space: 32,
  /**
   * '"'
   */
  quotationMark: 34,
  /**
   * '#'
   */
  hash: 35,
  /**
   * ' ' '
   */
  apostrophe: 39,
  /**
   * '('
   */
  openingParentheses: 40,
  /**
   * '*'
   */
  star: 42,
  /**
   * '-'
   */
  dash: 45,
  /**
   * '.'
   */
  dot: 46,
  /**
   * ':'
   */
  colon: 58,
  /**
   * '<'
   */
  LessThan: 60,
  /**
   * '='
   */
  equals: 61,
  /**
   * '>'
   */
  greaterThan: 62,
  /**
   * 'X'
   */
  uppercaseX: 88,
  /**
   * '['
   */
  openingSquareBracket: 91,
  /**
   * '\'
   */
  backSlash: 92,
  /**
   * ']'
   */
  closingSquareBracket: 93,
  /**
   * '_'
   */
  underscore: 95,
  /**
   * '`'
   */
  backTick: 96,
  /**
   * 'x'
   */
  lowercaseX: 120,
  /**
   * '{'
   */
  openingCurlyBracket: 123,
  /**
   * '}'
   */
  closingCurlyBracket: 125,
  /**
   * '~'
   */
  tilde: 126
};
function createLabel(effects, ok, nok, type, markerType, stringType, disallowEol) {
  let size = 0;
  let balance = 0;
  return start;
  function start(code) {
    if (code !== Codes.openingSquareBracket) {
      throw new Error("expected `[`");
    }
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    return afterStart;
  }
  function afterStart(code) {
    if (code === Codes.closingSquareBracket) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok;
    }
    effects.enter(stringType);
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === Codes.EOF || size > 999) {
      return nok(code);
    }
    if (code === Codes.closingSquareBracket && !balance--) {
      return atClosingBrace(code);
    }
    if (markdownLineEnding(code)) {
      if (disallowEol) {
        return nok(code);
      }
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkText", { contentType: "text" });
    return label2(code);
  }
  function label2(code) {
    if (code === Codes.EOF || markdownLineEnding(code) || size > 999) {
      effects.exit("chunkText");
      return atBreak(code);
    }
    if (code === Codes.openingSquareBracket && ++balance > 3) {
      return nok(code);
    }
    if (code === Codes.closingSquareBracket && !balance--) {
      effects.exit("chunkText");
      return atClosingBrace(code);
    }
    effects.consume(code);
    return code === Codes.backSlash ? labelEscape : label2;
  }
  function atClosingBrace(code) {
    effects.exit(stringType);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.exit(type);
    return ok;
  }
  function labelEscape(code) {
    if (code === Codes.openingSquareBracket || code === Codes.backSlash || code === Codes.closingSquareBracket) {
      effects.consume(code);
      size++;
      return label2;
    }
    return label2(code);
  }
}
var label$2 = { tokenize: tokenizeLabel$2, partial: true };
var gfmCheck = { tokenize: checkGfmTaskCheckbox, partial: true };
var doubleBracketCheck = { tokenize: checkDoubleBracket, partial: true };
function tokenize$6(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    if (code !== Codes.openingSquareBracket) {
      throw new Error("expected `[`");
    }
    if (self.previous === Codes.EOF && self._gfmTasklistFirstContentOfListItem) {
      return effects.check(gfmCheck, nok, attemptLabel)(code);
    }
    if (self.previous === Codes.openingSquareBracket) {
      return nok(code);
    }
    return effects.check(doubleBracketCheck, nok, attemptLabel)(code);
  }
  function attemptLabel(code) {
    effects.enter("textSpan");
    return effects.attempt(label$2, exit, nok)(code);
  }
  function exit(code) {
    if (code === Codes.openingParentheses || code === Codes.openingSquareBracket) {
      return nok(code);
    }
    return exitOK(code);
  }
  function exitOK(code) {
    effects.exit("textSpan");
    return ok(code);
  }
}
function tokenizeLabel$2(effects, ok, nok) {
  return createLabel(effects, ok, nok, "componentTextLabel", "componentTextLabelMarker", "componentTextLabelString");
}
var tokenizeSpan = {
  tokenize: tokenize$6
};
function checkGfmTaskCheckbox(effects, ok, nok) {
  return enter;
  function enter(code) {
    effects.enter("formGfmTaskCheckbox");
    effects.consume(code);
    return check;
  }
  function check(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return check;
    }
    if (code === Codes.uppercaseX || code === Codes.lowercaseX) {
      effects.consume(code);
      return check;
    }
    if (code === Codes.closingSquareBracket) {
      effects.exit("formGfmTaskCheckbox");
      return ok(code);
    }
    return nok(code);
  }
}
function checkDoubleBracket(effects, ok, nok) {
  return enter;
  function enter(code) {
    effects.enter("doubleBracket");
    effects.consume(code);
    return check;
  }
  function check(code) {
    if (code !== Codes.openingSquareBracket) {
      return nok(code);
    }
    effects.exit("doubleBracket");
    return ok(code);
  }
}
function createAttributes(effects, ok, nok, attributesType, attributesMarkerType, attributeType, attributeIdType, attributeClassType, attributeNameType, attributeInitializerType, attributeValueLiteralType, attributeValueType, attributeValueMarker, attributeValueData, disallowEol) {
  let type;
  let marker;
  let isBindAttribute = false;
  return start;
  function start(code) {
    effects.enter(attributesType);
    effects.enter(attributesMarkerType);
    effects.consume(code);
    effects.exit(attributesMarkerType);
    return between;
  }
  function between(code) {
    if (code === Codes.hash) {
      type = attributeIdType;
      return shortcutStart(code);
    }
    if (code === Codes.dot) {
      type = attributeClassType;
      return shortcutStart(code);
    }
    if (code === Codes.colon || code === Codes.underscore || asciiAlpha(code)) {
      effects.enter(attributeType);
      effects.enter(attributeNameType);
      effects.consume(code);
      isBindAttribute = code === Codes.colon;
      return code === Codes.colon ? bindAttributeName : name;
    }
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, between, "whitespace")(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, between)(code);
    }
    return end(code);
  }
  function shortcutStart(code) {
    effects.enter(attributeType);
    effects.enter(type);
    effects.enter(type + "Marker");
    effects.consume(code);
    effects.exit(type + "Marker");
    return shortcutStartAfter;
  }
  function shortcutStartAfter(code) {
    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.hash || code === Codes.apostrophe || code === Codes.dot || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick || code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {
      return nok(code);
    }
    effects.enter(type + "Value");
    effects.consume(code);
    return shortcut2;
  }
  function shortcut2(code) {
    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.apostrophe || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick) {
      return nok(code);
    }
    if (code === Codes.dot || code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {
      effects.exit(type + "Value");
      effects.exit(type);
      effects.exit(attributeType);
      return between(code);
    }
    effects.consume(code);
    return shortcut2;
  }
  function bindAttributeName(code) {
    if (code === Codes.dash || asciiAlphanumeric(code)) {
      effects.consume(code);
      return bindAttributeName;
    }
    effects.exit(attributeNameType);
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, bindAttributeNameAfter, "whitespace")(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, bindAttributeNameAfter)(code);
    }
    return bindAttributeNameAfter(code);
  }
  function bindAttributeNameAfter(code) {
    if (code === Codes.equals) {
      effects.enter(attributeInitializerType);
      effects.consume(code);
      effects.exit(attributeInitializerType);
      return valueBefore;
    }
    effects.exit(attributeType);
    return nok(code);
  }
  function name(code) {
    if (code === Codes.dash || code === Codes.dot || code === Codes.colon || code === Codes.underscore || asciiAlphanumeric(code)) {
      effects.consume(code);
      return name;
    }
    effects.exit(attributeNameType);
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, nameAfter, "whitespace")(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, nameAfter)(code);
    }
    return nameAfter(code);
  }
  function nameAfter(code) {
    if (code === Codes.equals) {
      effects.enter(attributeInitializerType);
      effects.consume(code);
      effects.exit(attributeInitializerType);
      return valueBefore;
    }
    effects.exit(attributeType);
    return between(code);
  }
  function valueBefore(code) {
    if (code === Codes.EOF || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick || code === Codes.closingCurlyBracket || disallowEol && markdownLineEnding(code)) {
      return nok(code);
    }
    if (code === Codes.quotationMark || code === Codes.apostrophe) {
      effects.enter(attributeValueLiteralType);
      effects.enter(attributeValueMarker);
      effects.consume(code);
      effects.exit(attributeValueMarker);
      marker = code;
      return valueQuotedStart;
    }
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, valueBefore, "whitespace")(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, valueBefore)(code);
    }
    effects.enter(attributeValueType);
    effects.enter(attributeValueData);
    effects.consume(code);
    marker = void 0;
    return valueUnquoted;
  }
  function valueUnquoted(code) {
    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.apostrophe || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick) {
      return nok(code);
    }
    if (code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {
      effects.exit(attributeValueData);
      effects.exit(attributeValueType);
      effects.exit(attributeType);
      return between(code);
    }
    effects.consume(code);
    return valueUnquoted;
  }
  function valueQuotedStart(code) {
    if (code === marker) {
      effects.enter(attributeValueMarker);
      effects.consume(code);
      effects.exit(attributeValueMarker);
      effects.exit(attributeValueLiteralType);
      effects.exit(attributeType);
      return valueQuotedAfter;
    }
    effects.enter(attributeValueType);
    return valueQuotedBetween(code);
  }
  function valueQuotedBetween(code) {
    if (code === marker) {
      effects.exit(attributeValueType);
      return valueQuotedStart(code);
    }
    if (code === Codes.EOF) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      return disallowEol ? nok(code) : factoryWhitespace(effects, valueQuotedBetween)(code);
    }
    effects.enter(attributeValueData);
    effects.consume(code);
    return valueQuoted;
  }
  function valueQuoted(code) {
    if (isBindAttribute && code === Codes.backSlash) {
      effects.exit(attributeValueData);
      effects.exit(attributeValueType);
      effects.enter("escapeCharacter");
      effects.consume(code);
      effects.exit("escapeCharacter");
      effects.enter(attributeValueType);
      effects.enter(attributeValueData);
      return valueQuotedEscape;
    }
    if (code === marker || code === Codes.EOF || markdownLineEnding(code)) {
      effects.exit(attributeValueData);
      return valueQuotedBetween(code);
    }
    effects.consume(code);
    return valueQuoted;
  }
  function valueQuotedEscape(code) {
    effects.consume(code);
    return valueQuoted;
  }
  function valueQuotedAfter(code) {
    return code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code) ? between(code) : end(code);
  }
  function end(code) {
    if (code === Codes.closingCurlyBracket) {
      effects.enter(attributesMarkerType);
      effects.consume(code);
      effects.exit(attributesMarkerType);
      effects.exit(attributesType);
      return ok;
    }
    return nok(code);
  }
}
var attributes$2 = { tokenize: tokenizeAttributes$2, partial: true };
var validEvents = [
  /**
   * Span
   */
  "textSpan",
  /**
   * Bold & Italic
   */
  "attentionSequence",
  /**
   * Inline Code
   */
  "codeText",
  /**
   * Link
   */
  "link",
  /**
   * Image
   */
  "image"
];
function tokenize$5(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    if (code !== Codes.openingCurlyBracket) {
      throw new Error("expected `{`");
    }
    const event = self.events[self.events.length - 1];
    if (markdownLineEnding(self.previous) || !event || !validEvents.includes(event[1].type)) {
      return nok(code);
    }
    return effects.attempt(attributes$2, ok, nok)(code);
  }
}
function tokenizeAttributes$2(effects, ok, nok) {
  return createAttributes(
    effects,
    ok,
    nok,
    "componentTextAttributes",
    "componentTextAttributesMarker",
    "componentTextAttribute",
    "componentTextAttributeId",
    "componentTextAttributeClass",
    "componentTextAttributeName",
    "componentTextAttributeInitializerMarker",
    "componentTextAttributeValueLiteral",
    "componentTextAttributeValue",
    "componentTextAttributeValueMarker",
    "componentTextAttributeValueData"
  );
}
var tokenizeAttribute = {
  tokenize: tokenize$5
};
function attempClose(effects, ok, nok) {
  return start;
  function start(code) {
    if (code !== Codes.closingCurlyBracket) {
      return nok(code);
    }
    effects.exit("bindingContent");
    effects.enter("bindingFence");
    effects.consume(code);
    return secondBracket;
  }
  function secondBracket(code) {
    if (code !== Codes.closingCurlyBracket) {
      return nok(code);
    }
    effects.consume(code);
    effects.exit("bindingFence");
    return ok;
  }
}
function tokenize$4(effects, ok, nok) {
  return start;
  function start(code) {
    if (code !== Codes.openingCurlyBracket) {
      throw new Error("expected `{`");
    }
    effects.enter("bindingFence");
    effects.consume(code);
    return secondBracket;
  }
  function secondBracket(code) {
    if (code !== Codes.openingCurlyBracket) {
      return nok(code);
    }
    effects.consume(code);
    effects.exit("bindingFence");
    effects.enter("bindingContent");
    return content;
  }
  function content(code) {
    if (code === Codes.closingCurlyBracket) {
      return effects.attempt({ tokenize: attempClose, partial: true }, close, (code2) => {
        effects.consume(code2);
        return content;
      })(code);
    }
    effects.consume(code);
    return content;
  }
  function close(code) {
    return ok(code);
  }
}
var tokenizeBinding = {
  tokenize: tokenize$4
};
function createName(effects, ok, nok, nameType) {
  const self = this;
  return start;
  function start(code) {
    if (asciiAlpha(code)) {
      effects.enter(nameType);
      effects.consume(code);
      return name;
    }
    return nok(code);
  }
  function name(code) {
    if (code === Codes.dash || code === Codes.underscore || asciiAlphanumeric(code)) {
      effects.consume(code);
      return name;
    }
    effects.exit(nameType);
    return self.previous === Codes.underscore ? nok(code) : ok(code);
  }
}
var label$1 = { tokenize: tokenizeLabel$1, partial: true };
var attributes$1 = { tokenize: tokenizeAttributes$1, partial: true };
function previous(code) {
  return code !== Codes.colon || this.events[this.events.length - 1]?.[1]?.type === "characterEscape";
}
function tokenize$3(effects, ok, nok) {
  const self = this;
  return start;
  function start(code) {
    if (code !== Codes.colon) {
      throw new Error("expected `:`");
    }
    if (self.previous !== null && !markdownLineEndingOrSpace(self.previous) && ![Codes.openingSquareBracket, Codes.star, Codes.underscore, Codes.openingParentheses].includes(self.previous)) {
      return nok(code);
    }
    if (!previous.call(self, self.previous)) {
      throw new Error("expected correct previous");
    }
    effects.enter("componentText");
    effects.enter("componentTextMarker");
    effects.consume(code);
    effects.exit("componentTextMarker");
    return createName.call(self, effects, afterName, nok, "componentTextName");
  }
  function afterName(code) {
    if (code === Codes.colon) {
      return nok(code);
    }
    if (code === Codes.openingSquareBracket) {
      return effects.attempt(label$1, afterLabel, afterLabel)(code);
    }
    if (code === Codes.openingCurlyBracket) {
      return effects.attempt(attributes$1, afterAttributes, afterAttributes)(code);
    }
    return exit(code);
  }
  function afterAttributes(code) {
    if (code === Codes.openingSquareBracket) {
      return effects.attempt(label$1, afterLabel, afterLabel)(code);
    }
    return exit(code);
  }
  function afterLabel(code) {
    if (code === Codes.openingCurlyBracket) {
      return effects.attempt(attributes$1, exit, exit)(code);
    }
    return exit(code);
  }
  function exit(code) {
    effects.exit("componentText");
    return ok(code);
  }
}
function tokenizeLabel$1(effects, ok, nok) {
  return createLabel(effects, ok, nok, "componentTextLabel", "componentTextLabelMarker", "componentTextLabelString");
}
function tokenizeAttributes$1(effects, ok, nok) {
  return createAttributes(
    effects,
    ok,
    nok,
    "componentTextAttributes",
    "componentTextAttributesMarker",
    "componentTextAttribute",
    "componentTextAttributeId",
    "componentTextAttributeClass",
    "componentTextAttributeName",
    "componentTextAttributeInitializerMarker",
    "componentTextAttributeValueLiteral",
    "componentTextAttributeValue",
    "componentTextAttributeValueMarker",
    "componentTextAttributeValueData"
  );
}
var tokenizeInline = {
  tokenize: tokenize$3,
  previous
};
function sizeChunks(chunks) {
  let index = -1;
  let size = 0;
  while (++index < chunks.length) {
    size += typeof chunks[index] === "string" ? chunks[index].length : 1;
  }
  return size;
}
function prefixSize(events, type) {
  const tail = events[events.length - 1];
  if (!tail || tail[1].type !== type) {
    return 0;
  }
  return sizeChunks(tail[2].sliceStream(tail[1]));
}
function linePrefixSize(events) {
  let size = 0;
  let index = events.length - 1;
  let tail = events[index];
  while (index >= 0 && tail && tail[1].type === "linePrefix" && tail[0] === "exit") {
    size += sizeChunks(tail[2].sliceStream(tail[1]));
    index -= 1;
    tail = events[index];
  }
  return size;
}
var useTokenState = (tokenName) => {
  const token = {
    isOpen: false,
    /**
     * Enter into token, close previous open token if any
     */
    enter: (effects) => {
      const initialState = token.isOpen;
      token.exit(effects);
      effects.enter(tokenName);
      token.isOpen = true;
      return () => {
        token.isOpen = initialState;
      };
    },
    /**
     * Enter into token only once, if token is already open, do nothing
     */
    enterOnce: (effects) => {
      const initialState = token.isOpen;
      if (!token.isOpen) {
        effects.enter(tokenName);
        token.isOpen = true;
      }
      return () => {
        token.isOpen = initialState;
      };
    },
    /**
     * Exit from token if it is open
     */
    exit: (effects) => {
      const initialState = token.isOpen;
      if (token.isOpen) {
        effects.exit(tokenName);
        token.isOpen = false;
      }
      return () => {
        token.isOpen = initialState;
      };
    }
  };
  return token;
};
var tokenizeCodeFence = { tokenize: checkCodeFenced, partial: true };
function checkCodeFenced(effects, ok, nok) {
  let backTickCount = 0;
  return start;
  function start(code) {
    effects.enter("codeFenced");
    return after(code);
  }
  function after(code) {
    if (code === Codes.backTick || code === Codes.tilde) {
      backTickCount++;
      effects.consume(code);
      return after;
    }
    effects.exit("codeFenced");
    if (backTickCount >= 3) {
      return ok(code);
    }
    return nok(code);
  }
}
function tokenizeFrontMatter(effects, ok, _nok, next, initialPrefix) {
  let previous2;
  return effects.attempt({
    tokenize: tokenizeDataSection,
    partial: true
  }, dataSectionOpen, next);
  function tokenizeDataSection(effects2, ok2, nok) {
    const self = this;
    let size = 0;
    let sectionIndentSize = 0;
    return closingPrefixAfter;
    function dataLineFirstSpaces(code) {
      if (markdownSpace(code)) {
        effects2.consume(code);
        sectionIndentSize += 1;
        return dataLineFirstSpaces;
      }
      effects2.exit("space");
      return closingPrefixAfter(code);
    }
    function closingPrefixAfter(code) {
      if (markdownSpace(code)) {
        effects2.enter("space");
        return dataLineFirstSpaces(code);
      }
      if (sectionIndentSize === 0) {
        sectionIndentSize = linePrefixSize(self.events);
      }
      effects2.enter("componentContainerSectionSequence");
      return closingSectionSequence(code);
    }
    function closingSectionSequence(code) {
      if (code === Codes.dash || markdownSpace(code)) {
        effects2.consume(code);
        size++;
        return closingSectionSequence;
      }
      if (size < SectionSequenceSize) {
        return nok(code);
      }
      if (sectionIndentSize !== initialPrefix) {
        return nok(code);
      }
      if (!markdownLineEnding(code)) {
        return nok(code);
      }
      effects2.exit("componentContainerSectionSequence");
      return factorySpace(effects2, ok2, "whitespace")(code);
    }
  }
  function dataSectionOpen(code) {
    effects.enter("componentContainerDataSection");
    return effects.attempt({
      tokenize: tokenizeDataSection,
      partial: true
    }, dataSectionClose, dataChunkStart)(code);
  }
  function dataChunkStart(code) {
    if (code === null) {
      effects.exit("componentContainerDataSection");
      effects.exit("componentContainer");
      return ok(code);
    }
    const token = effects.enter("chunkDocument", {
      contentType: "document",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return dataContentContinue(code);
  }
  function dataContentContinue(code) {
    if (code === null) {
      effects.exit("chunkDocument");
      effects.exit("componentContainerDataSection");
      effects.exit("componentContainer");
      return ok(code);
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit("chunkDocument");
      return effects.attempt({
        tokenize: tokenizeDataSection,
        partial: true
      }, dataSectionClose, dataChunkStart);
    }
    effects.consume(code);
    return dataContentContinue;
  }
  function dataSectionClose(code) {
    effects.exit("componentContainerDataSection");
    return factorySpace(effects, next, "whitespace")(code);
  }
}
var label = { tokenize: tokenizeLabel, partial: true };
var attributes = { tokenize: tokenizeAttributes, partial: true };
function tokenize$2(effects, ok, nok) {
  const self = this;
  const initialPrefix = linePrefixSize(this.events);
  let sizeOpen = 0;
  let previous2;
  const childContainersSequenceSize = [];
  let containerFirstLine = true;
  let possibleIndentedComponent = false;
  let containerIndentSize = 0;
  let visitingCodeFenced = false;
  const section = useTokenState("componentContainerSection");
  return start;
  function start(code) {
    if (code !== Codes.colon) {
      throw new Error("expected `:`");
    }
    effects.enter("componentContainer");
    effects.enter("componentContainerFence");
    effects.enter("componentContainerSequence");
    return sequenceOpen(code);
  }
  function tokenizeSectionClosing(effects2, ok2, nok2) {
    let size = 0;
    let sectionIndentSize = 0;
    let revertSectionState;
    return closingPrefixAfter;
    function closingPrefixAfter(code) {
      sectionIndentSize = linePrefixSize(self.events);
      revertSectionState = section.exit(effects2);
      effects2.enter("componentContainerSectionSequence");
      return closingSectionSequence(code);
    }
    function closingSectionSequence(code) {
      if (code === slotSeparatorCode) {
        effects2.consume(code);
        size++;
        return closingSectionSequence;
      }
      if (size !== slotSeparatorLength) {
        revertSectionState();
        return nok2(code);
      }
      if (sectionIndentSize !== initialPrefix) {
        revertSectionState();
        return nok2(code);
      }
      if (!asciiAlpha(code)) {
        revertSectionState();
        return nok2(code);
      }
      effects2.exit("componentContainerSectionSequence");
      return factorySpace(effects2, ok2, "whitespace")(code);
    }
  }
  function sectionOpen(code) {
    section.enter(effects);
    if (markdownLineEnding(code)) {
      return factorySpace(effects, lineStart, "whitespace")(code);
    }
    effects.enter("componentContainerSectionTitle");
    return sectionTitle(code);
  }
  function sectionTitle(code) {
    if (code === Codes.openingCurlyBracket) {
      return effects.check(
        attributes,
        (code2) => {
          effects.exit("componentContainerSectionTitle");
          return effects.attempt(attributes, factorySpace(effects, lineStart, "linePrefix", 4), nok)(code2);
        },
        (code2) => {
          effects.consume(code2);
          return sectionTitle;
        }
      )(code);
    }
    if (markdownLineEnding(code)) {
      effects.exit("componentContainerSectionTitle");
      return factorySpace(effects, lineStart, "linePrefix", 4)(code);
    }
    effects.consume(code);
    return sectionTitle;
  }
  function sequenceOpen(code) {
    if (code === Codes.colon) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    if (sizeOpen < ContainerSequenceSize) {
      return nok(code);
    }
    effects.exit("componentContainerSequence");
    return createName.call(self, effects, afterName, nok, "componentContainerName")(code);
  }
  function afterName(code) {
    return code === Codes.openingSquareBracket ? effects.attempt(label, afterLabel, afterLabel)(code) : afterLabel(code);
  }
  function afterLabel(code) {
    return code === Codes.openingCurlyBracket ? effects.attempt(attributes, afterAttributes, afterAttributes)(code) : afterAttributes(code);
  }
  function afterAttributes(code) {
    return factorySpace(effects, openAfter, "whitespace")(code);
  }
  function openAfter(code) {
    effects.exit("componentContainerFence");
    if (code === null) {
      effects.exit("componentContainer");
      return ok(code);
    }
    if (markdownLineEnding(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return self.interrupt ? ok : contentStart;
    }
    return nok(code);
  }
  function contentStart(code) {
    if (code === null) {
      effects.exit("componentContainer");
      return ok(code);
    }
    if (containerFirstLine && (code === Codes.dash || markdownSpace(code))) {
      containerFirstLine = false;
      return tokenizeFrontMatter(effects, ok, nok, contentStart, initialPrefix)(code);
    }
    effects.enter("componentContainerContent");
    return lineStart(code);
  }
  function lineStartAfterPrefix(code) {
    if (code === null) {
      return after(code);
    }
    if (code === Codes.backTick) {
      return effects.check(
        tokenizeCodeFence,
        (code2) => {
          visitingCodeFenced = !visitingCodeFenced;
          return chunkStart(code2);
        },
        chunkStart
      )(code);
    }
    if (visitingCodeFenced) {
      return chunkStart(code);
    }
    if (!childContainersSequenceSize.length && (code === slotSeparatorCode || code === Codes.space)) {
      return effects.attempt(
        { tokenize: tokenizeSectionClosing, partial: true },
        sectionOpen,
        chunkStart
      )(code);
    }
    if (code === Codes.colon) {
      return effects.attempt(
        { tokenize: tokenizeClosingFence, partial: true },
        after,
        chunkStart
      )(code);
    }
    return chunkStart(code);
  }
  function dentendIndentedCommponent(code) {
    if (containerIndentSize) {
      return factorySpace(effects, lineStartAfterPrefix, "linePrefix", containerIndentSize + 1)(code);
    }
    return lineStartAfterPrefix(code);
  }
  function attemptIntentedCommponent(code) {
    if (containerIndentSize) {
      return factorySpace(effects, lineStartAfterPrefix, "linePrefix", containerIndentSize + 1)(code);
    }
    return effects.check(
      { tokenize: tokenizeContainerIndent, partial: true },
      dentendIndentedCommponent,
      lineStartAfterPrefix
    )(code);
  }
  function lineStart(code) {
    if (code === null) {
      return after(code);
    }
    let nextState = dentendIndentedCommponent;
    if (possibleIndentedComponent) {
      nextState = attemptIntentedCommponent;
    }
    possibleIndentedComponent = markdownLineEnding(code);
    return initialPrefix > 0 ? factorySpace(effects, nextState, "linePrefix", initialPrefix + 1)(code) : nextState(code);
  }
  function chunkStart(code) {
    if (code === null) {
      return after(code);
    }
    section.enterOnce(effects);
    const token = effects.enter("chunkDocument", {
      contentType: "document",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return contentContinue(code);
  }
  function contentContinue(code) {
    if (code === null) {
      effects.exit("chunkDocument");
      return after(code);
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit("chunkDocument");
      return lineStart;
    }
    effects.consume(code);
    return contentContinue;
  }
  function after(code) {
    section.exit(effects);
    effects.exit("componentContainerContent");
    effects.exit("componentContainer");
    return ok(code);
  }
  function tokenizeClosingFence(effects2, ok2, nok2) {
    let size = 0;
    return factorySpace(effects2, closingPrefixAfter, "linePrefix", 4);
    function closingPrefixAfter(code) {
      effects2.enter("componentContainerFence");
      effects2.enter("componentContainerSequence");
      return closingSequence(code);
    }
    function closingSequence(code) {
      if (code === Codes.colon) {
        effects2.consume(code);
        size++;
        return closingSequence;
      }
      if (childContainersSequenceSize.length) {
        if (size === childContainersSequenceSize[childContainersSequenceSize.length - 1]) {
          childContainersSequenceSize.pop();
        }
        return nok2(code);
      }
      if (size !== sizeOpen) {
        return nok2(code);
      }
      effects2.exit("componentContainerSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code);
    }
    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects2.exit("componentContainerFence");
        return ok2(code);
      }
      childContainersSequenceSize.push(size);
      return nok2(code);
    }
  }
  function tokenizeContainerIndent(effects2, ok2, nok2) {
    let size = 0;
    function start2(code) {
      if (code !== Codes.space) {
        return nok2(code);
      }
      return factory(code);
    }
    function factory(code) {
      effects2.enter("linePrefix");
      if (code === Codes.space) {
        effects2.consume(code);
        size += 1;
        return factory;
      }
      return containerCheck(code);
    }
    return start2;
    function containerCheck(code) {
      if (code === Codes.colon && size > 0) {
        containerIndentSize = size;
        return ok2(code);
      }
      if (markdownLineEnding(code)) {
        possibleIndentedComponent = false;
        containerIndentSize = 0;
        return ok2(code);
      }
      return nok2(code);
    }
  }
}
function tokenizeLabel(effects, ok, nok) {
  return createLabel(
    effects,
    ok,
    nok,
    "componentContainerLabel",
    "componentContainerLabelMarker",
    "componentContainerLabelString",
    true
  );
}
function tokenizeAttributes(effects, ok, nok) {
  return createAttributes(
    effects,
    ok,
    nok,
    "componentContainerAttributes",
    "componentContainerAttributesMarker",
    "componentContainerAttribute",
    "componentContainerAttributeId",
    "componentContainerAttributeClass",
    "componentContainerAttributeName",
    "componentContainerAttributeInitializerMarker",
    "componentContainerAttributeValueLiteral",
    "componentContainerAttributeValue",
    "componentContainerAttributeValueMarker",
    "componentContainerAttributeValueData",
    true
  );
}
var tokenizeContainer = {
  tokenize: tokenize$2,
  concrete: true
};
function tokenize$1(effects, ok, nok) {
  const self = this;
  return factorySpace(effects, lineStart, "linePrefix");
  function lineStart(code) {
    if (prefixSize(self.events, "linePrefix") < 4) {
      return nok(code);
    }
    switch (code) {
      case Codes.backTick:
        return codeFenced.tokenize.call(self, effects, ok, nok)(code);
      case Codes.colon:
        return tokenizeContainer.tokenize.call(self, effects, ok, nok)(code);
      default:
        return nok(code);
    }
  }
}
var tokenizeContainerIndented = {
  tokenize: tokenize$1
};
function tokenize(effects, ok, nok) {
  const self = this;
  const tokenizeSugerSyntax = tokenizeInline.tokenize.call(
    self,
    effects,
    factorySpace(effects, exit, "linePrefix"),
    nok
  );
  return factorySpace(effects, lineStart, "linePrefix");
  function lineStart(code) {
    if (code === Codes.colon) {
      return tokenizeSugerSyntax(code);
    }
    return nok(code);
  }
  function exit(code) {
    if (markdownLineEnding(code) || code === Codes.EOF) {
      return ok(code);
    }
    return nok(code);
  }
}
var tokenizeContainerSuger = {
  tokenize
};
function micromarkComponentsExtension() {
  return {
    text: {
      [Codes.colon]: tokenizeInline,
      [Codes.openingSquareBracket]: [tokenizeSpan],
      [Codes.openingCurlyBracket]: [tokenizeBinding, tokenizeAttribute]
    },
    flow: {
      [Codes.colon]: [tokenizeContainer, tokenizeContainerSuger]
    },
    flowInitial: {
      "-2": tokenizeContainerIndented,
      "-1": tokenizeContainerIndented,
      [Codes.space]: tokenizeContainerIndented
    }
  };
}
var toFrontMatter = (yamlString) => `---
${yamlString}
---`;
var remarkMDC = (function remarkMDC2(opts = {}) {
  const data = this.data();
  if (opts.autoUnwrap === void 0 && opts.experimental?.autoUnwrap) {
    opts.autoUnwrap = opts.experimental.autoUnwrap ? { safeTypes: [] } : false;
  }
  opts.attributes ||= {};
  opts.attributes.maxLength = opts.attributes.maxLength ?? opts.maxAttributesLength ?? 80;
  opts.attributes.yamlCodeBlock = opts.attributes.yamlCodeBlock ?? opts.yamlCodeBlockProps ?? opts.experimental?.componentCodeBlockYamlProps ?? false;
  add("micromarkExtensions", micromarkComponentsExtension());
  add("fromMarkdownExtensions", fromMarkdown(opts));
  add("toMarkdownExtensions", toMarkdown(opts));
  function add(field, value) {
    if (!data[field]) {
      data[field] = [];
    }
    data[field].push(value);
  }
  if (opts?.components?.length) {
    return async (tree, { data: data2 }) => {
      const jobs = [];
      visit(tree, ["textComponent", "leafComponent", "containerComponent"], (node) => {
        bindNode(node, opts["frontmatter"]);
        const { instance: handler, options } = opts.components.find((c) => c.name === node.name) || {};
        if (handler) {
          jobs.push(handler(options)(node, data2));
        }
      });
      await Promise.all(jobs);
      return tree;
    };
  }
  return (tree) => {
    visit(tree, ["textComponent", "leafComponent", "containerComponent"], (node) => {
      bindNode(node, opts["frontmatter"]);
    });
  };
});
function bindNode(node, options) {
  const nodeData = node.data || (node.data = {});
  node.fmAttributes = getNodeData(node, options);
  nodeData.hName = kebabCase(node.name);
  nodeData.hProperties = bindData(
    {
      ...node.attributes,
      // Parse data slots and retrieve data
      ...node.fmAttributes
    }
  );
}
function getNodeData(node, options) {
  if (node.rawData) {
    const yaml = node.rawData.replace(/\s-+$/, "");
    const { data } = parseFrontMatter(toFrontMatter(yaml), options);
    return data;
  }
  return {};
}
function bindData(data) {
  const entries = Object.entries(data).map(([key2, value]) => {
    if (key2.startsWith(":")) {
      return [key2, value];
    }
    if (typeof value === "string") {
      return [key2, value];
    }
    return [`:${key2}`, JSON.stringify(value)];
  });
  return Object.fromEntries(entries);
}
export {
  convertHtmlEntitiesToChars,
  remarkMDC as default,
  micromarkComponentsExtension as micromarkExtension,
  parseFrontMatter,
  stringifyFrontMatter
};
//# sourceMappingURL=@nuxtjs_mdc___remark-mdc.js.map
